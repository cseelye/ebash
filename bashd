#!/usr/bin/env bash

# Bashd is a long running instance of bash which can be used to execute bash commands in a native bash environment 
# even if the caller is not running bash. The advantage to this approach as opposed to alternative approaches with
# calling something like system() directly is it removes the need for fork and exec which oftentimes cannot be
# safely called in some environments. The common use case for this is when a process has massive amounts of memory
# allocated (e.g. 256GB) and tries to fork+exec bash (e.g. via system) the process can easily be OOM'd between the
# fork and the exec while the kernel is going through and marking all the pages as copy on write. Other attempts to
# solve this problem differently with a long-running embedded bash instance suffer different problems which are
# prone to race conditions around pipe handline and process lifetime management.
#
# Bashd is an exceedingly simple solution to this problem which exposes a simple API wherein the caller creates
# a temporary directory in a known queue directory with mktemp(1) or mktemp(3) with a special control file named
# 'options' which contains a set of key=value entries which control what bashd will do. The only required key in
# this file is 'cmdline' which indicates the command that should be invoked by bashd. For a full list of these
# options see the OPTIONS section below. Bashd will then execute the command on behalf of the caller and write
# the command's STDOUT and STDERR into files named 'stdout' and 'stderr' inside that same temporary directory.
# Once the process is completed, it will capture its return code and write that out into a file named 'rc' in
# that same temporary directory.
#
# The caller can simply poll waiting for the creation of the 'rc' file as a signal that the process has finished
# at which point it can then read its stdout, stderr and rc files. The recommended efficient way to achieve this
# is using inotify(7) rather than manually polling waiting for the file to be created. Bashd itself uses inotify(7)
# in order to very efficiently wait for new jobs to be created without having to poll. It also takes care of
# reaping the status of these jobs so as to not have a bunch of unreaped processes filling the process table.
# Finally, bashd is careful to run each process in its own execution environment without sourcing any initialization
# files to ensure as pristine an environment as possible.
#
# OPTIONS
# =======
#
# The following are the keys used to control bashd functionality on a per-command basis.
#
# cmdline
#   The command line to be run. This includes the executable as well as any of its arguments. This could be a simple
#   command, a compound command, or refer to some external and arbitrarily complex script or binary. If the command
#   has whitespace in it be sure to quote the whitespace properly and bashd will honor it.
#
# timeout
#   Optional timeout to kill the command it hasn't exited. If it's a simple number, the duration will be a number in
#   seconds. You may also specify suffixes in the same format the timeout command accepts them. For instance, you
#   might specify 5m or 1h or 2d for 5 minutes, 1 hour, or 2 days, respectively. If the command is timedout then it will
#   have a return code of 124 to match the behavior of the vanilla timeout(1) command. If the command fails to exit
#   after receiving requested signal it will send SIGKILL to the process. If this happens the return code will still be
#   124 since we rely on that return code to indicate that a process timedout and was prematurely terminated.
#
#----------------------------------------------------------------------------------------------------------------------
# FUNCTIONS
#----------------------------------------------------------------------------------------------------------------------

: ${BASHUTILS:=$(dirname $0)}
source ${BASHUTILS}/bashutils.sh || { echo "Failed to source ${BASHUTILS}/bashutils.sh" ; exit 1 ; }

# handle_job is an internal function which handles a single job. This takes care of actually spawning a clean
# instance of bash and executing the command given to it by the caller and storing the stdout, stderr and return 
# code into files in the specified job directory.
handle_job()
{
    local job="${1}"
    local rc=0
    echo "${BASHPID}" > "${job}/pid"
    
    # Extract options for this job
    local cmdline=$(grep -Po 'cmdline=\K(.*)' ${job}/options)
    local timeout=$(grep -Po 'timeout=\K(.*)' ${job}/options || true)
    : ${timeout:="infinity"}
    einfo "${job} :: Starting ${BASHPID} $(lval cmdline timeout) options=$(cat ${job}/options)"

    # Launch bash with restricted environment to reduce changes of environmental blead over. Specifically:
    # --noprofile    Do not read either the system-wide startup file /etc/profile or any of the personal initialization file
    # --norc         Do not read/execute system wide initialization file and personal initialization file ~/.bashrc
    # -c <cmd>       Execute commands in string.
    #
    # NOTE: This code purposefully diables fatal error handling by the "&& rc=0 || rc=$?" idiom. This is because we
    #       do not want a failure in this command to cause bashd itself to exit. Moreover, we don't care about any
    #       set -e error handling or traps since we specifically want a pristine environment and are thus launching
    #       a fresh instance of bash.
    etimeout -t=${timeout} bash --noprofile --norc -c "exec 1>${job}/stdout 2>${job}/stderr; ${cmdline}" && rc=0 || rc=$?
    echo "${rc}" >"${job}/rc"
    einfo "${job} :: Complete ${BASHPID} (${cmdline}) rc=${rc} stdout=\"$(cat ${job}/stdout)\" stderr=\"$(cat ${job}/stderr)\""
}

#----------------------------------------------------------------------------------------------------------------------
# MAIN
#----------------------------------------------------------------------------------------------------------------------

# Parse options including the queue directory to use. This defaults to just '/var/run/bashd'.
$(declare_args -g ?queue)
: ${queue:=/var/run/bashd}
queue=$(readlink -m "${queue}")
efreshdir ${queue}

# Track the PIDs of the backgrounded processes that bashd launches. These are really only tracked for debugging
# purposes and do not affect the core functionality of bashd itself.
pids=()
PID=$$
ebanner "Starting up bashd" QUEUE=queue PID

# Enter into an infinite loop waiting for jobs to be created. Feed them into our main event loop which will hand them
# off to handle_job or prune completed jobs as appropriate.
inotifywait --recursive --monitor --format "%e:%w%f" -e create "${queue}" | \
while read entry; do

    # Event contains the event type (e.g. CREATE) followed by a colon followed by the path that was created.
    # Parse out the event type and job path.
    event=${entry%%:*}
    job=${entry#*:}
    edebug "$(lval event job pids)"

    # If this is a completed job wait on the pid so that its process state is reaped
    if [[ ${event} == "CREATE" && ${job} == "${queue}"/*/rc ]]; then
        pid=$(cat $(dirname ${job})/pid)
        rc=$(cat ${job})
        wait "${pid}" || true
        array_remove pids ${pid}

    # This case handles the scenario where the options file is created after the original temp job directory
    # is created. E.g. they've done a 'mkdir queue/foo' then later move the options file into that directory.
    elif [[ ${event} == "CREATE" && ${job} == "${queue}"/*/options ]]; then
        handle_job "$(dirname ${job})" &
        pids+=( $! )

    # This case handles the scenario where an entire directory is created which already contains the options
    # file and the the entire directory is moved into the queue directory.
    elif [[ ${event} == "CREATE,ISDIR" && -e ${job}/options ]]; then
        handle_job "${job}" &
        pids+=( $! )
    fi

    edebug "$(lval pids)"

done

