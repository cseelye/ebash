#!/usr/bin/env bash

: ${BASHUTILS:=/usr/local/share/bashutils}
PATH=".:${PATH}:${BASHUTILS}"
source efuncs.sh || { echo "Unable to source efuncs." ; exit 1 ; }

[[ -z ${1} || -n ${3} ]] && die "etest only accepts one or two arguments"

TEST_DIR=$1
$(esource ${TEST_DIR}/*.sh)

#-------------------------------------------------------------------------------------------------------------------------
# TEST UTILITY FUNCTIONS
#-------------------------------------------------------------------------------------------------------------------------

assert_true()
{
    local expression="${@}"
    edebug "$(lval expression)"

    eval "${expression}" || { die "Expect failed :: $(lval expression)"; return 1; }
    return 0
}

assert_false()
{
    local expression="${@}"
    edebug "$(lval expression)"

    eval "${expression}" && { die "Expect failed :: ! $(lval expression)"; return 1; }
    return 0
}

assert_op()
{
    compare "${@}" || { die "assert_op failed :: ${@}"; return 1; }
    return 0
}

assert_eq()
{
    $(declare_args ?lh ?rh)
    [[ "${lh}" == "${rh}" ]] || { die "assert_eq failed :: $(lval lh rh)"; return 1; } 
}

assert_ne()
{
    $(declare_args ?lh ?rh)
    [[ ! "${lh}" == "${rh}" ]] || { error "assert_ne failed :: $(lval lh rh)"; return 1; }
}

assert_zero()
{
    [[ $1 -eq 0 ]] || { die "assert_zero received $1 instead of zero." ; return 1 ; }
}

assert_not_zero()
{
    [[ $1 -ne 0 ]] || { die "assert_not_zero received ${1}." ; return 1 ; }
}

assert_empty()
{
    [[ $1 == "" ]] || { die "assert_empty received \"$1\"." ; return 1 ; }
}

assert_not_empty()
{
    [[ $1 != "" ]] || { die "assert_not_empty received an empty string." ; return 1 ; }
}

#-------------------------------------------------------------------------------------------------------------------------
# MAIN
#-------------------------------------------------------------------------------------------------------------------------

# Get all function names that begin with ETEST_ (and optionally match $2)
ETEST_FUNCTIONS=( $(declare -F | awk '$3 ~ "^ETEST" && $3 ~ "'$2'" {print $3}') )

# Figure out longest test name
ETEST_LONGEST=0
ETEST_LEN=0
for testfunc in "${ETEST_FUNCTIONS[@]}"; do
    ETEST_LEN=${#testfunc}
    (( ETEST_LEN > ETEST_LONGEST )) && ETEST_LONGEST=${ETEST_LEN}
done

edebug "Running tests $(lval ETEST_FUNCTIONS)"
# And execute them
ETEST_RC=0
for testfunc in "${ETEST_FUNCTIONS[@]}" ; do

    # If debugging is not enabled for testfunc just show a brief message with test name
    if edebug_enabled ${testfunc}; then
        ebanner ${testfunc}
    else
        pad=$((ETEST_LONGEST-${#testfunc}+1))
        msg=$(printf "%s%${pad}s" "${testfunc}" " ")
        einfon "${msg}"
    fi

    # Create a specific directory to run this test in. That way the test can create whatever directories and files it
    # needs and assuming the test succeeds we'll auto remove the directory after the test completes.
    TEST_DIR_OUTPUT="${TEST_DIR}/output/${testfunc}"
    
    eval "${testfunc}_internal() { 
    (
        emkdir ${TEST_DIR_OUTPUT}
        cd ${TEST_DIR_OUTPUT}
        ${testfunc}
    ) &> \$(edebug_out)
    }"

    ${testfunc}_internal
    rc=$?

    # If the test succeeded remove it's contents
    [[ ${ETEST_CLEAN:-1} -eq 1 && ${rc} -eq 0 ]] \
        && { edebug "Cleaning ${TEST_DIR_OUTPUT}"; eunmount_recursive ${TEST_DIR_OUTPUT} &>$(edebug_out); erm ${TEST_DIR_OUTPUT}; }

    (( ETEST_RC += $rc ))
    edebug_enabled ${testfunc} || eend ${rc}

done

exit ${ETEST_RC}
