#!/usr/bin/env bash

## Check if we're root and re-execute if we're not through sudo ##
if [[ $(id -u) != "0" ]]; then
    sudo -E "$0" "$@"
    exit $?
fi

: ${BASHUTILS:=$(dirname $0)}
source $(dirname $0)/efuncs.sh || source ${BASHUTILS}/efuncs.sh || { echo "Unable to source efuncs." ; exit 1 ; }

[[ "$#" -eq 1 || "$#" -eq 2 ]] || die "etest only accepts one or two arguments"
TEST_DIR=$(readlink -m $1)
FILTER=${2:-}

#-------------------------------------------------------------------------------------------------------------------------
# TEST UTILITY FUNCTIONS
#-------------------------------------------------------------------------------------------------------------------------

assert_true()
{
    local array=( "${@}" )
    local cmd=$(array_quote array)
    
    eval ${cmd} || { die "assert_true failed :: $(lval cmd)"; return 1; }
    return 0
}

assert()
{
    assert_true "${@}"
}

assert_false()
{
    local array=( "${@}" )
    local cmd=$(array_quote array)

    eval ${cmd} && { die "assert_false failed :: ! $(lval cmd)"; return 1; }
    return 0
}

assert_op()
{
    compare "${@}" || { die "assert_op failed :: ${@}"; return 1; }
    return 0
}

assert_eq()
{
    $(declare_args ?lh ?rh)
    [[ "${lh}" == "${rh}" ]] || { die "assert_eq failed :: $(lval lh rh)"; return 1; } 
}

assert_ne()
{
    $(declare_args ?lh ?rh)
    [[ ! "${lh}" == "${rh}" ]] || { die "assert_ne failed :: $(lval lh rh)"; return 1; }
}

assert_zero()
{
    [[ ${1:-0} -eq 0 ]] || { die "assert_zero received $1 instead of zero." ; return 1 ; }
}

assert_not_zero()
{
    [[ ${1:-1} -ne 0 ]] || { die "assert_not_zero received ${1}." ; return 1 ; }
}

assert_empty()
{
    local _arg
    for _arg in $@; do
        [[ "${!_arg:-""}" == "" ]] || die "assert_empty received $(lval _arg)"
    done
}

assert_not_empty()
{
    local _arg
    for _arg in $@; do
        [[ "${!_arg}" != "" ]] || die "assert_not_empty received $(lval _arg)"
    done
}

global_setup()
{
    # Create a specific directory to run this test in. That way the test can create whatever directories and files it
    # needs and assuming the test succeeds we'll auto remove the directory after the test completes.
    TEST_DIR_OUTPUT="${TEST_DIR}/output"
    mkdir -p ${TEST_DIR_OUTPUT}
}

global_teardown()
{
    argcheck TEST_DIR_OUTPUT
    if [[ ${ETEST_CLEAN:-1} -ne 0 ]] ; then
        eunmount_recursive ${TEST_DIR_OUTPUT}
        rm -rf ${TEST_DIR_OUTPUT}
    fi
}

test_setup()
{
    # Unit test infrastructure setup
    argcheck TEST_DIR_OUTPUT
    mkdir -p ${TEST_DIR_OUTPUT}/${testfunc}

    # Unit test provided setup
    declare -f setup &>/dev/null && { setup || die "Setup failed." ; } 

    return 0
}

test_teardown()
{
    # Unit test provided teardown
    declare -f teardown &>/dev/null && { teardown || die "Setup failed." ; }

    # Unit test infrastructure teardown
    argcheck testfunc
    if [[ ${ETEST_CLEAN:-1} -ne 0 ]] ; then
        eunmount_recursive ${TEST_DIR_OUTPUT}/${testfunc}
        rm -rf ${TEST_DIR_OUTPUT}/${testfunc}
    fi

    return 0
}

#-------------------------------------------------------------------------------------------------------------------------
# MAIN
#-------------------------------------------------------------------------------------------------------------------------

FAILED_FILES=()
global_setup
trap_add global_teardown ERR HUP INT QUIT BUS PIPE TERM EXIT

for testfile in $(find ${TEST_DIR}/*.sh); do

    # Each test file gets its own subshell
    try
    {
        FAILED_TESTS=()
        $(esource ${testfile})

        # Get all function names that begin with ETEST_ (and optionally match $2)
        [[ ${testfile} =~ ${FILTER} ]] && ETEST_FUNCTIONS=( $(declare -F | awk '$3 ~ "^ETEST" {print $3}' ) ) \
                                       || ETEST_FUNCTIONS=( $(declare -F | awk '$3 ~ "^ETEST" && $3 ~ "'${FILTER}'" {print $3}') )

        [[ ${#ETEST_FUNCTIONS[@]} -eq 0 ]] && continue

        edebug_enabled ${testfile} || einfo "Starting tests in ${testfile}"

        for testfunc in "${ETEST_FUNCTIONS[@]}" ; do

            # If debugging is not enabled for testfunc just show a brief message with test name
            testfunc_rc=0 
            edebug_enabled ${testfunc} && ebanner ${testfunc} || einfos ${testfunc}

            try
            {
                test_setup
                cd ${TEST_DIR_OUTPUT}/${testfunc}
                ${testfunc}
                test_teardown
            } &> $(edebug_out) 
            catch
            {
                testfunc_rc=$?
                FAILED_TESTS+=( ${testfunc/ETEST_/} )
                test_teardown
            }

            edebug_enabled ${testfunc} || eend ${testfunc_rc}
           
        done

        [[ ${#FAILED_TESTS[@]} -eq 0 ]] || die "$(lval FAILED_TESTS)"
    } 
    catch
    {
        FAILED_FILES+=( $(basename ${testfile}) ) || true
    }

done

[[ ${#FAILED_FILES[@]} -eq 0 ]] || die "$(lval FAILED_FILES)"

exit 0
