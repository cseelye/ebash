#!/usr/bin/env bash

## Check if we're root and re-execute if we're not through sudo ##
if [[ $(id -u) != "0" ]]; then
    sudo -E "$0" "$@"
    exit $?
fi

: ${BASHUTILS:=$(dirname $0)}
PATH=".:${PATH}:${BASHUTILS}"
source efuncs.sh || { echo "Unable to source efuncs." ; exit 1 ; }

[[ -z ${1} || -n ${3} ]] && die "etest only accepts one or two arguments"
TEST_DIR=$(readlink -m $1)
FILTER=$2

#-------------------------------------------------------------------------------------------------------------------------
# TEST UTILITY FUNCTIONS
#-------------------------------------------------------------------------------------------------------------------------

assert_true()
{
    local expression="${@}"
    eval "${expression}" || { die "Expect failed :: $(lval expression)"; return 1; }
    return 0
}

assert_false()
{
    local expression="${@}"
    eval "${expression}" && { die "Expect failed :: ! $(lval expression)"; return 1; }
    return 0
}

assert_op()
{
    compare "${@}" || { die "assert_op failed :: ${@}"; return 1; }
    return 0
}

assert_eq()
{
    $(declare_args ?lh ?rh)
    [[ "${lh}" == "${rh}" ]] || { die "assert_eq failed :: $(lval lh rh)"; return 1; } 
}

assert_ne()
{
    $(declare_args ?lh ?rh)
    [[ ! "${lh}" == "${rh}" ]] || { error "assert_ne failed :: $(lval lh rh)"; return 1; }
}

assert_zero()
{
    [[ $1 -eq 0 ]] || { die "assert_zero received $1 instead of zero." ; return 1 ; }
}

assert_not_zero()
{
    [[ $1 -ne 0 ]] || { die "assert_not_zero received ${1}." ; return 1 ; }
}

assert_empty()
{
    [[ $1 == "" ]] || { die "assert_empty received \"$1\"." ; return 1 ; }
}

assert_not_empty()
{
    [[ $1 != "" ]] || { die "assert_not_empty received an empty string." ; return 1 ; }
}

global_setup()
{
    # Create a specific directory to run this test in. That way the test can create whatever directories and files it
    # needs and assuming the test succeeds we'll auto remove the directory after the test completes.
    TEST_DIR_OUTPUT="${TEST_DIR}/${testfunc}"
    emkdir ${TEST_DIR_OUTPUT}
    cd ${TEST_DIR_OUTPUT}
}

global_teardown()
{
    argcheck TEST_DIR_OUTPUT

    # If the test succeeded remove it's contents
    if [[ ${ETEST_CLEAN:-1} -eq 1 ]] ; then
        edebug "Cleaning ${TEST_DIR_OUTPUT}"
        eunmount_recursive ${TEST_DIR_OUTPUT}
        erm ${TEST_DIR_OUTPUT}
    fi
}

run_setup()
{
    global_setup
    declare -f setup &>/dev/null && { setup || die "Setup failed." ; }
    return 0
}

run_teardown()
{
    declare -f teardown &>/dev/null && { teardown || die "Setup failed." ; }
    global_teardown
    return 0
}

#-------------------------------------------------------------------------------------------------------------------------
# MAIN
#-------------------------------------------------------------------------------------------------------------------------

# Various return codes:
# - ETEST_RC:      Global return code for entire etest run.
# - ETEST_ETEST_FILE_RC: Return code for all the tests in a given file (e.g. the text fixture)
# - ETEST_TEST_RC: Return code for a signle test.
ETEST_RC=0
ETEST_FILE_RC=0
ETEST_TEST_RC=0

for testfile in ${TEST_DIR}/*.sh ; do
    # Each test file gets its own subshell
    (
        ETEST_FILE_RC=0
        $(esource ${testfile})

        # Get all function names that begin with ETEST_ (and optionally match $2)
        ETEST_FUNCTIONS=( $(declare -F | awk '$3 ~ "^ETEST" && $3 ~ "'${FILTER}'" {print $3}') )

        if [[ ${#ETEST_FUNCTIONS[@]} -eq 0 ]] ; then
            continue
        fi

        ! edebug_enabled ${testfunc} && einfo "Starting tests in ${testfile}"

        for testfunc in "${ETEST_FUNCTIONS[@]}" ; do

            # If debugging is not enabled for testfunc just show a brief message with test name
            edebug_enabled ${testfunc} && ebanner ${testfunc} || einfos "${testfunc}"

            eval "${testfunc}_internal() { 
            (
                EFUNCS_FATAL=0
                run_setup
                ${testfunc}
                run_teardown
            ) &> \$(edebug_out)
            }"

            ${testfunc}_internal
            ETEST_TEST_RC=$?

            (( ETEST_FILE_RC += ${ETEST_TEST_RC} ))
            edebug_enabled ${testfunc} || eend ${ETEST_TEST_RC}
        done

        if [[ ${ETEST_FILE_RC} -eq 0 ]] ; then
            einfo "Tests passed: ${testfile}\n"
        else
            eerror "Tests failed: ${testfile}\n"
        fi

        exit ${ETEST_FILE_RC}
    )

    (( ETEST_RC += $? ))
done

exit ${ETEST_RC}
