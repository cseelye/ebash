#!/usr/bin/env bash

## Check if we're root and re-execute if we're not through sudo ##
if [[ $(id -u) != "0" ]]; then
    sudo -E "$0" "$@"
    exit $?
fi

: ${BASHUTILS:=$(dirname $0)}
source ${BASHUTILS}/efuncs.sh || { echo "Unable to source efuncs." ; exit 1 ; }

$(esource ${BASHUTILS}/cgroup.sh)
[[ "$#" -eq 1 || "$#" -eq 2 ]] || die "etest only accepts one or two arguments"
TEST_DIR=$(readlink -m $1)
FILTER=${2:-}

# Global cgroup name for all unit tests
export ETEST_CGROUP="etest/$(basename ${TEST_DIR})-$$"

#-------------------------------------------------------------------------------------------------------------------------
# TEST UTILITY FUNCTIONS
#-------------------------------------------------------------------------------------------------------------------------

assert_no_process_leaks()
{
    cgroup_move "/etest" $$ ${BASHPID}
    
    local remaining_processes=$(cgroup_ps ${ETEST_CGROUP} || true)
    if [[ -n ${remaining_processes} ]]; then
        cgroup_kill_and_wait -s=SIGKILL ${ETEST_CGROUP}
        cgroup_destroy -r ${ETEST_CGROUP}
        die "Stale processes:\n${remaining_processes}"
    fi
}

global_setup()
{
    # Create a specific directory to run this test in. That way the test can create whatever directories and files it
    # needs and assuming the test succeeds we'll auto remove the directory after the test completes.
    TEST_DIR_OUTPUT="${TEST_DIR}/output"
    mkdir -p ${TEST_DIR_OUTPUT}

    [[ -n "$(cgroup_pids etest)" ]] && { ewarn "Killing stale etest processes=($(cgroup_pids etest))" ; cgroup_kill_and_wait -s=SIGKILL etest ; }

    # And a cgroup that will contain all output
    cgroup_create ${ETEST_CGROUP}
    cgroup_move ${ETEST_CGROUP} $$
}

global_teardown()
{
    edebug "etest global teardown"

    assert_no_process_leaks
   
    argcheck TEST_DIR_OUTPUT
    if [[ ${ETEST_CLEAN:-1} -ne 0 ]] ; then
        eunmount_recursive ${TEST_DIR_OUTPUT}
        rm -rf ${TEST_DIR_OUTPUT}
    fi
}

test_setup()
{
    # Unit test infrastructure setup
    argcheck TEST_DIR_OUTPUT
    mkdir -p ${TEST_DIR_OUTPUT}/${testfunc}

    # Unit test provided setup
    declare -f setup &>/dev/null && { setup || die "Setup failed." ; } 

    return 0
}

test_teardown()
{
    edebug "Tearing down for test ${testfunc}"

    # Unit test provided teardown
    declare -f teardown &>/dev/null && { teardown || die "Setup failed." ; }

    assert_no_process_leaks

    # Unit test infrastructure teardown
    argcheck testfunc
    if [[ ${ETEST_CLEAN:-1} -ne 0 ]] ; then
        eunmount_recursive ${TEST_DIR_OUTPUT}/${testfunc}
        rm -rf ${TEST_DIR_OUTPUT}/${testfunc}
    fi

    return 0
}

#-------------------------------------------------------------------------------------------------------------------------
# SANITY TEST OF DIE FUNCTIONALITY
#-------------------------------------------------------------------------------------------------------------------------

# Manually test die() functionality outside of try/catch to ensure basic trap functionality works properly.
DIE_TEST_MSG="Verifying die() trap functionality"
edebug_enabled && ebanner "${DIE_TEST_MSG}" || einfo "${DIE_TEST_MSG}"
{
    DIE_FILE="etest_die.txt"
    rm -f ${DIE_FILE}

    die_handler()
    {
        einfo "DIE_HANDLER called"
        echo "DIE" >> ${DIE_FILE}
    }

    trap_add "einfo TRAP; echo TRAP >> ${DIE_FILE}"
    die "Fake death..."

    # Assert proper order of events happened
    einfo "Ensuring TRAP was called before DIE"
    cat ${DIE_FILE}
    first=$(head -1 ${DIE_FILE})
    last=$(tail -1 ${DIE_FILE})

    [[ ${first} == "TRAP" ]] || { eerror "TRAP NOT CALLED FIRST"; exit 1; }
    [[ ${last}  == "DIE"  ]] || { eerror "DIE NOT CALLED LAST";   exit 1; }

} &>$(edebug_out)

rm -f ${DIE_FILE}

eend

#-------------------------------------------------------------------------------------------------------------------------
# MAIN
#-------------------------------------------------------------------------------------------------------------------------

die_handler()
{
    edebug "DIE triggered: cleaning up..."
    global_teardown
    exit 1
}

trap - ${DIE_SIGNALS[@]} ERR EXIT
die_on_abort
die_on_error

FAILED_FILES=()
global_setup
trap_add global_teardown

# Now go through and test all unit tests
for testfile in $(find ${TEST_DIR}/*.sh); do

    # Each test file gets its own subshell
    try
    {
        FAILED_TESTS=()
        $(esource ${testfile})

        # Ensure proper shebang is in the unit test or else bashlint won't be able to validate it
        # and it may not be a proper bash unit test
        grep -q '^#!/.*bash' ${testfile} || { eerror "No bash shebang in ${testfile}"; throw 1; }

        # Get all function names that begin with ETEST_ (and optionally match $2)
        [[ ${testfile} =~ ${FILTER} ]] && ETEST_FUNCTIONS=( $(declare -F | awk '$3 ~ "^ETEST" {print $3}' ) ) \
                                       || ETEST_FUNCTIONS=( $(declare -F | awk '$3 ~ "^ETEST" && $3 ~ "'${FILTER}'" {print $3}') )

        [[ ${#ETEST_FUNCTIONS[@]} -gt 0 ]] || continue

        edebug_enabled ${testfile} || einfo "Starting tests in ${testfile}"

        for testfunc in "${ETEST_FUNCTIONS[@]}" ; do

            # If debugging is not enabled for testfunc just show a brief message with test name
            testfunc_rc=0 
            edebug_enabled ${testfunc} && ebanner ${testfunc} || einfos ${testfunc}

            try
            {
                test_setup
                cd ${TEST_DIR_OUTPUT}/${testfunc}
                ${testfunc}
            } &> $(edebug_out) 
            catch
            {
                testfunc_rc=$?
                FAILED_TESTS+=( ${testfunc/ETEST_/} )
            }
            test_teardown

            eend ${testfunc_rc}
           
        done

        array_empty FAILED_TESTS || { eerror_stacktrace "$(lval FAILED_TESTS)"; echo; throw 1; }
    } 
    catch
    {
        FAILED_FILES+=( $(basename ${testfile}) ) || true
    }

done

array_empty FAILED_FILES || eerror "$(lval FAILED_FILES)"

exit ${#FAILED_FILES[@]}
