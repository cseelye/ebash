#!/usr/bin/env bash

BANNER_WIDTH=50
ARCHIVE_TYPES=(
    squashfs
    tar
    iso
    tar.gz
)

assert_archive_contents()
{
    $(declare_args archive)
    etestmsg "Validating $(lval archive)"
    
    local expect=( "${@}" )
    array_sort expect

    assert_exists "${archive}"
    local actual=( $(archive_list ${archive}) )

    einfo "$(lval expect)"
    einfo "$(lval actual)"

    assert_eq "${#expect[@]}" "${#actual[@]}" "Size mismatch"

    local idx
    for idx in $(array_indexes expect); do
        eval "local e=\${expect[$idx]}"
        eval "local a=\${actual[$idx]}"

        assert_eq "${e}" "${a}" "Mismatch at index=${idx}"
    done
}

assert_directory_contents()
{
    $(declare_args directory)
    etestmsg "Validating $(lval directory)"

    local expect=( "${@}" )
    array_sort expect
    
    assert_exists "${directory}"
    local actual=( $(find "${directory}" -printf '%P\n' | sort) )

    einfo "$(lval expect)"
    einfo "$(lval actual)"

    assert_eq "${#expect[@]}" "${#actual[@]}" "Size mismatch"

    local idx
    for idx in $(array_indexes expect); do
        eval "local e=\${expect[$idx]}"
        eval "local a=\${actual[$idx]}"

        assert_eq "${e}" "${a}" "Mismatch at index=${idx}"
    done
}

ETEST_archive_create()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating dest.${ftype}"
        archive_create src dest.${ftype}
        assert_archive_contents dest.${ftype} src src/file1 src/file2
    done
}

ETEST_archive_create_single_file()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        cd src
        touch file1

        etestmsg "Creating dest.${ftype}"
        archive_create file1 dest.${ftype}
        assert_archive_contents dest.${ftype} file1
    done
}

ETEST_archive_create_single_filetree()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        mkdir -p src/sub1/sub2
        touch src/sub1/sub2/file1

        etestmsg "Creating dest.${ftype}"
        archive_create src/sub1/sub2/file1 dest.${ftype}
        assert_archive_contents dest.${ftype} src src/sub1 src/sub1/sub2 src/sub1/sub2/file1
    done
}

ETEST_archive_create_directory_dot()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src/. src.${ftype}
        assert_archive_contents src.${ftype} src src/file1 src/file2
    done
}

ETEST_archive_create_directory()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        assert_not_exists DIR
        archive_create src DIR/src.${ftype}
        assert_archive_contents DIR/src.${ftype} src src/file1 src/file2
        rm -rf DIR
    done
}

ETEST_archive_create_files()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4}
        
        etestmsg "Creating src.${ftype}"
        archive_create file1 file2 file3 file4 src.${ftype}
        assert_archive_contents src.${ftype} file1 file2 file3 file4

        rm --force src.${ftype}
    done
}

ETEST_archive_create_missing_files()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4}
 
        etestmsg "Creating src.${ftype} (should do nothing)"
        archive_create -i NOT1 NOT2 src.${ftype}
        assert_not_exists src.${ftype}
        
        etestmsg "Creating src.${ftype} (should fail)"
        assert_false archive_create NOT1 file1 file2 file3 file4 NOT2 src.${ftype}
        #BUG: assert_not_exists src.${ftype}

        etestmsg "Creating src.${ftype} (ignoring missing files -- should pass)"
        archive_create -i NOT1 file1 file2 file3 file4 NOT2 src.${ftype}
        assert_archive_contents src.${ftype} file1 file2 file3 file4
        
        rm src.${ftype}
    done
}

ETEST_archive_create_mixed_files_directories()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src1 src2
        touch file0 src1/{file1,file2} src2/{file3,file4}

        etestmsg "Creating src.${ftype}"
        archive_create file0 src1 src2 src.${ftype}
        assert_archive_contents src.${ftype} file0 src1 src1/{file1,file2} src2 src2/{file3,file4}

        rm src.${ftype}
    done
}

ETEST_archive_create_exclude()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2,XXX,YYY}
        
        etestmsg "Creating src.${ftype}"
        archive_create -x="src/XXX src/YYY" src src.${ftype}
        assert_archive_contents src.${ftype} src src/file1 src/file2
    done
}

ETEST_archive_create_exclude_illegal_prefix()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        local src=$(mktemp -d /tmp/archive-XXXX)
        touch ${src}/{file1,file2}

        etestmsg "Creating src/dest.${ftype}"
        local dest=$(mktemp /tmp/archive-XXXX.${ftype})
        archive_create ${src} ${dest}
        assert_archive_contents ${dest} $(dirname ${src##/}) ${src##/} ${src##/}/file1 ${src##/}/file2
    done
}

ETEST_archive_create_exclude_glob()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src src/tmp
        touch src/{file1,file2}
        touch src/tmp/{t1,t2,t3,t10,x1,x2,x3}

        etestmsg "Creating src.${ftype} (excluding tmp/*)"
        archive_create -x="src/tmp/*" src src.${ftype}
        assert_archive_contents src.${ftype} src src/file1 src/file2 src/tmp
        rm src.${ftype}

        etestmsg "Creating src.${ftype} (excluding tmp/t?)"
        archive_create -x="src/tmp/t?" src src.${ftype}
        assert_archive_contents src.${ftype} src src/file1 src/file2 src/tmp src/tmp/t10 src/tmp/x1 src/tmp/x2 src/tmp/x3

        etestmsg "Creating src.${ftype} (excluding tmp/t* tmp/x*)"
        archive_create -x="src/tmp/t* src/tmp/x*" src src.${ftype}
        assert_archive_contents src.${ftype} src src/file1 src/file2 src/tmp
    done
}

ETEST_archive_create_exclude_self()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src/dest.${ftype}"
        archive_create src src/dest.${ftype}
        assert_archive_contents src/dest.${ftype} src src/file1 src/file2
    done
}

# Ensure extra slashes in destination path doesn't cause archive_create to fail.
ETEST_archive_create_exclude_self_canonicalize()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src/dest.${ftype}"
        archive_create src src///././///dest.${ftype}
        assert_archive_contents src/dest.${ftype} src src/file1 src/file2
    done
}

# Realistic test of archiving pivot rooted rootfs
ETEST_archive_create_pivot_root()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        local oldroot=$(mktemp -d /tmp/oldroot-XXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        archive_create ${oldroot} ${oldroot}//var/log/sfbackup.${ftype}
        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            tmp                                                \
            ${oldroot#/}                                       \
            ${oldroot#/}/boot                                  \
            ${oldroot#/}/boot/initramfs-x86_64-3.12.13-gentoo  \
            ${oldroot#/}/boot/kernel-x86_64-3.12.13-gentoo     \
            ${oldroot#/}/boot/System.map-x86_64-3.12.13-gentoo \
            ${oldroot#/}/var                                   \
            ${oldroot#/}/var/log                               \
            ${oldroot#/}/var/log/sf-master-10.info             \
            ${oldroot#/}/var/log/sf-master-1.info              \
            ${oldroot#/}/var/log/sf-master-2.info              \
            ${oldroot#/}/var/log/sf-master-3.info              \
            ${oldroot#/}/var/log/sf-master-4.info              \
            ${oldroot#/}/var/log/sf-master-5.info              \
            ${oldroot#/}/var/log/sf-master-6.info              \
            ${oldroot#/}/var/log/sf-master-7.info              \
            ${oldroot#/}/var/log/sf-master-8.info              \
            ${oldroot#/}/var/log/sf-master-9.info
    done
}

# Realistic test of archiving pivot rooted rootfs
ETEST_archive_create_pivot_root_cd()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        local oldroot=$(mktemp -d /tmp/oldroot-XXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        (
            cd ${oldroot}
            archive_create . ${oldroot}/var/log/sfbackup.${ftype}
        )

        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info
    done
}

# Realistic test of archiving pivot rooted rootfs with multiple paths specified
ETEST_archive_create_pivot_root_multi()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        local oldroot=$(mktemp -d /tmp/oldroot-XXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        KEEP_PATHS=( /boot /var )
        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        (
            cd ${oldroot}
            archive_create ${KEEP_PATHS[@]##/} ${oldroot}/var/log/sfbackup.${ftype}
        )

        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info
    done
}

ETEST_archive_extract_pivot_root_multi_deep()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        local oldroot=$(mktemp -d /tmp/oldroot-XXXX)
        etestmsg "Populating oldroot directory"
        mkdir -p ${oldroot}/{boot,var/log}
        touch ${oldroot}/boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
        touch ${oldroot}/var/log/sf-master-{1..10}.info

        KEEP_PATHS=( /boot/{initramfs-x86_64-3.12.13-gentoo,kernel-x86_64-3.12.13-gentoo,System.map-x86_64-3.12.13-gentoo}
                     /var/log/sf-master-{1..10}.info
                    )

        local expect=(                              \
            boot                                    \
            boot/initramfs-x86_64-3.12.13-gentoo    \
            boot/kernel-x86_64-3.12.13-gentoo       \
            boot/System.map-x86_64-3.12.13-gentoo   \
            var                                     \
            var/log                                 \
            var/log/sf-master-10.info               \
            var/log/sf-master-1.info                \
            var/log/sf-master-2.info                \
            var/log/sf-master-3.info                \
            var/log/sf-master-4.info                \
            var/log/sf-master-5.info                \
            var/log/sf-master-6.info                \
            var/log/sf-master-7.info                \
            var/log/sf-master-8.info                \
            var/log/sf-master-9.info                \
        )

        etestmsg "Creating ${oldroot}/var/log/sfbackup.${ftype}"
        (
            cd ${oldroot}
            find . -printf '%P\n'
            archive_create ${KEEP_PATHS[@]##/} ${oldroot}/var/log/sfbackup.${ftype}
        )
        assert_archive_contents ${oldroot}/var/log/sfbackup.${ftype} ${expect[@]}

        etestmsg "Extracting"
        archive_extract ${oldroot}/var/log/sfbackup.${ftype} restore ${KEEP_PATHS[@]##/}
        assert_directory_contents restore ${expect[@]}
    done
}

ETEST_archive_create_exclude_self_multi()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src1 src2
        touch src1/{file1,file2} src2/{file3,file4}

        etestmsg "Creating src1/dest.${ftype}"
        archive_create src1 src2 src1/dest.${ftype}
        assert_archive_contents src1/dest.${ftype} src1 src1/{file1,file2} src2 src2/{file3,file4}
    done
}

ETEST_archive_create_exclude_files()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Creating files"
        touch {file1,file2,file3,file4,XXX,YYY}
        
        etestmsg "Creating dest.${ftype}"
        archive_create -x="XXX YYY" file1 file2 file3 file4 XXX YYY src.${ftype}
        assert_archive_contents src.${ftype} file1 file2 file3 file4 
        rm src.${ftype}
   done
}

ETEST_archive_extract()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract src.${ftype} dest

        etestmsg "Validating src and dest"
        diff --unified --recursive src dest/src
    done
}

ETEST_archive_extract_specific_files()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2,XXX,YYY}

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}

        etestmsg "Extracting src.${ftype}/{file1,file2} to dest"
        archive_extract src.${ftype} dest src/{file1,file2}
        assert_directory_contents dest src src/file1 src/file2
   done
}

ETEST_archive_extract_missing_required_files()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2,XXX,YYY}

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}

   done
}

ETEST_archive_extract_ignore_missing()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2,XXX,YYY}

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}

        etestmsg "Extracting src.${ftype}/{file1,file2} to dest (should fail)"
        assert_false archive_extract src.${ftype} dest src/NOT1 src/file1 src/file2 src/NOT2
        #BUG: assert directory_empty dest
        rm -rf dest

        etestmsg "Extracting src.${ftype}/{file1,file2} to dest (should NOT fail -- ignoring missing files)"
        archive_extract -i src.${ftype} dest src/NOT1 src/file1 src/file2 src/NOT2
        assert_directory_contents dest src src/file1 src/file2
        rm -rf dest

        etestmsg "Extracting src.${ftype} with nothing to do"
        archive_extract -i src.${ftype} dest NOT1 NOT2
        assert directory_empty dest
        rm -rf dest
    done
}

ETEST_archive_extract_glob()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src src/tmp dest
        touch src/{file1,file2,XXX,YYY,tmp/1,tmp/2}

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}
        archive_list src.${ftype}

        etestmsg "Extracting src.${ftype}/{file*,tmp/*} to dest"
        archive_extract src.${ftype} dest "src/file*" "src/tmp/*"
        assert_directory_contents dest src src/{file1,file2,tmp,tmp/1,tmp/2}
    done
}

ETEST_archive_extract_content()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}
        echo "data1" >src/file1
        echo "data2" >src/file2

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract src.${ftype} dest

        etestmsg "Validating src and dest"
        diff --unified --recursive src dest/src
    done
}

ETEST_archive_nice()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src dest
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create -n=1 src src.${ftype}

        etestmsg "Extracting src.${ftype} to dest"
        archive_extract -n=1 src.${ftype} dest

        etestmsg "Validating src and dest"
        diff --unified --recursive src dest/src
    done
}

ETEST_archive_xconvert()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}

        local other
        for other in ${ARCHIVE_TYPES[@]}; do
            
            etestmsg "Converting src.${ftype} to cpy.${other}"
            archive_convert src.${ftype} cpy.${other}

            etestmsg "Validating contents of cpy.${other}"
            local src_contents=( $(archive_list src.${ftype}) )
            local cpy_contents=( $(archive_list cpy.${other}) )
            etestmsg "$(lval src_contents cpy_contents)"
            assert_eq $(array_size src_contents) $(array_size cpy_contents)

            # Also compare and diff as arrays
            local src_contents_join=$(array_join src_contents :)
            local cpy_contents_join=$(array_join cpy_contents :)
            assert_eq "${src_contents_join}" "${cpy_contents_join}"
        done

    done
}

ETEST_archive_xdiff()
{
    local idx=0
    for idx in $(array_indexes ARCHIVE_TYPES); do
        local ftype="${ARCHIVE_TYPES[$idx]}"
        COLUMNS=${BANNER_WIDTH} ebanner "${ftype} ($((idx+1))/${#ARCHIVE_TYPES[@]})"

        etestmsg "Populating source directory"
        efreshdir src
        touch src/{file1,file2}

        etestmsg "Creating src.${ftype}"
        archive_create src src.${ftype}

        # Iterate over all types and create copy -- diff should match
        for other in ${ARCHIVE_TYPES[@]}; do
           
            etestmsg "Creating cpy.${other}"
            archive_create src cpy.${other}

            etestmsg "Diffing against cpy.${other}"
            archive_diff src.${ftype} cpy.${other}
        done

        # Iterate over all types and create a different copy with extra file
        # diff should not match.
        for other in ${ARCHIVE_TYPES[@]}; do
           
            etestmsg "Creating diff.${other}"
            efreshdir diff
            cp src/* diff
            touch diff/EXTRA_FILE
            archive_create diff diff.${other}

            etestmsg "Diffing against diff.${other} (should fail)"
            $(tryrc archive_diff src.${ftype} diff.${other})
            assert_ne 0 ${rc}
        done
    done
}
