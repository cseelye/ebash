#!/usr/bin/env bash

ETEST_efetch_md5_bogus()
{
    local tmpfile=$(mktemp --tmpdir etest-efetch-XXXXXX)
    touch ${tmpfile}.md5

    # efetch should fail b/c this isn't a valid MD5 file
    ! efetch -m file://${tmpfile}
}

ETEST_efetch_md5()
{
    local tmpfile=$(mktemp --tmpdir etest-efetch-XXXXXX)
    dd if=/dev/urandom of=${tmpfile} bs=1M count=2
    emd5sum ${tmpfile} > ${tmpfile}.md5

    efetch -m file://${tmpfile} copy.txt
    [[ -e copy.txt ]]
    [[ -e copy.txt.md5 ]]
    diff ${tmpfile} copy.txt
}

ETEST_efetch_md5_missing_md5()
{
    local tmpfile=$(mktemp --tmpdir etest-efetch-XXXXXX)
    dd if=/dev/urandom of=${tmpfile} bs=1M count=2

    # efetch should fail and both files should get removed
    ! efetch -m file://${tmpfile} copy.txt
    [[ ! -e copy.txt ]]
    [[ ! -e copy.txt.md5 ]]
}

ETEST_efetch_md5_missing_file()
{
    local tmpfile=$(mktemp --tmpdir etest-efetch-md5-XXXXXX)

    # efetch should fail and both files should get removed
    ! efetch -m file://${tmpfile%%.md5} copy.txt
    [[ ! -e copy.txt ]]
    [[ ! -e copy.txt.md5 ]]
}

ETEST_efetch_meta()
{
    local tmpfile=$(mktemp --tmpdir etest-efetch-XXXXXX)
    dd if=/dev/urandom of=${tmpfile} bs=1M count=2
    emetadata ${tmpfile} > ${tmpfile}.meta
    emetadata_check ${tmpfile}

    efetch -M file://${tmpfile} copy.txt
    [[ -e copy.txt ]]
    [[ -e copy.txt.meta ]]
    diff ${tmpfile} copy.txt

    emetadata_check copy.txt
}

ETEST_efetch_meta_pgp()
{
    [[ ${__BU_OS} == "Darwin" ]] && { ewarn "Test is disabled on Darwin per DT-188." ; return 0 ; }

    # Grab public and private keys as well as passphrase
    efetch http://bdr-jenkins.den.solidfire.net:/keys/solidfire_packaging_public.asc  public.asc
    efetch http://bdr-jenkins.den.solidfire.net:/keys/solidfire_packaging_private.asc private.asc
    efetch http://bdr-jenkins.den.solidfire.net:/keys/solidfire_packaging.phrase      phrase.txt
    
    local tmpfile=$(mktemp --tmpdir etest-efetch-XXXXXX)
    dd if=/dev/urandom of=${tmpfile} bs=1M count=2
    emetadata -p="private.asc" -k="$(cat phrase.txt)" ${tmpfile} > ${tmpfile}.meta
    emetadata_check ${tmpfile}

    efetch --meta --public-key "public.asc" file://${tmpfile} copy.txt
    [[ -e copy.txt ]]
    [[ -e copy.txt.meta ]]
    diff ${tmpfile} copy.txt

    emetadata_check -p="public.asc" copy.txt
}

# Older curl versions wrongly refused to create an empty file even if an empty file
# was successfully fetched. This test verifies efetch works around this dumb bug.
# See: https://github.com/curl/curl/issues/183
ETEST_efetch_empty_file()
{
    local tmpfile=$(mktemp --tmpdir etest-efetch-XXXXXX)
    assert_not_exists "dest"
    [[ ! -s "${tmpfile}" ]] || die "$(lval tmpfile) should be an empty file"

    # Try to fetch empty file. It should be created and be empty.
    efetch file://${tmpfile} "output.txt"
    assert_exists "output.txt"
    [[ ! -s "output.txt" ]] || die "output.txt should be an empty file."
}

ETEST_efetch_missing_dir()
{
    local tmpfile=$(mktemp --tmpdir etest-efetch-XXXXXX)
    dd if=/dev/urandom of=${tmpfile} bs=1M count=2
    assert_not_exists "dest"

    # Try to fetch it to a non-existant directory. It should create it for us.
    efetch file://${tmpfile} "dest/sub1/sub2/file1.txt"
    assert_exists "dest/sub1/sub2/file1.txt"
    assert_directory_contents "dest" "sub1" "sub1/sub2" "sub1/sub2/file1.txt"
}

ETEST_efetch_fail_curl()
{
    # Try to fetch file and force failure to verify the destination file does not exist
    curl()
    {
        # Grab the destination parameter from the curl command in efetch
	params=("$@")
        local dst=${params[3]}

	touch "${dst}"
	return 1
    }

    try {
        efetch "http://test" output.txt
        die "We should have caught an exception here"
    }
    catch {
        assert_not_exists output.txt
    }
}
