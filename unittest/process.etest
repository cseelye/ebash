#!/usr/bin/env bash

ETEST_process_hierarchy()
{
    local my_processes_file=$(mktemp --tmpdir pids_XXXXX)
    local ancestors_file=$(mktemp --tmpdir ancestors_XXXXX)
    local ancestors_noarg_file=$(mktemp --tmpdir ancestors_noarg_XXXXX)
    local children_file=$(mktemp --tmpdir children_XXXXX)
    local tree_file=$(mktemp --tmpdir tree_XXXXX)

    local first=$BASHPID
    echo $BASHPID >> ${my_processes_file}
    (
        echo $BASHPID >> ${my_processes_file}
        (
            echo $BASHPID >> ${my_processes_file}
            (
                echo $BASHPID >> ${my_processes_file}
                (
                    etestmsg "Process tree"
                    pstree $$

                    process_ancestors ${BASHPID} > ${ancestors_file}
                    process_ancestors > ${ancestors_noarg_file}

                    process_children ${first} > ${children_file}
                    process_tree ${first} > ${tree_file}
                )
            )
        )
    )

    local last=$(tail -n 1 ${my_processes_file})

    etestmsg "my_processes"
    cat ${my_processes_file}
    etestmsg "ancestors of ${last}"
    cat ${ancestors_noarg_file}
    etestmsg "ancestors_noarg of ${last}"
    cat ${ancestors_noarg_file}
    etestmsg "children of ${first}"
    cat ${children_file}

    local my_processes=( $(cat ${my_processes_file}) )
    local ancestors=( $(cat ${ancestors_file}) )
    local ancestors_noarg=( $(cat ${ancestors_noarg_file}) )
    local children=( $(cat ${children_file}) )
    local tree=( $(cat ${tree_file}) )

    etestmsg "Verifying children $(lval my_processes children first)"
    etestmsg "$(declare -p my_processes)"
    assert_eq 1 $(array_size children)
    assert_eq "${my_processes[1]}" "${children[0]}"


    # The rest of the verification steps are just checking that a list of
    # processes match, not checking them in order, so we'll sort them to make
    # that easier.
    array_sort my_processes ancestors ancestors_noarg children tree


    etestmsg "Verifying ancestors $(lval ancestors process)"
    # Note: there will be ancestors in the list that I don't know about
    # (for instance, the etest processes), but I know that the processes I
    # created and added to pids should be in there.  And so should init -- it's
    # the parent of everything.
    local process
    for process in 1 ${my_processes[@]} ; do
        assert array_contains ancestors ${process}
        assert array_contains ancestors_noarg ${process}
    done

    assert_false array_contains ancestors 0
    assert_false array_contains ancestors_noarg 0

    etestmsg "Verifying tree contains my processes $(lval tree my_processes)"
    for process in ${my_processes[@]} ; do
        assert array_contains tree ${process}
    done
}

ETEST_ekill()
{
    # Start a simple process and ensure we can kill it
    yes >/dev/null &
    local pid=$!
    eretry --max-timeout 5s process_running ${pid}

    ekill ${pid}
    wait ${pid} || true
    eretry --max-timeout 5s process_not_running ${pid}
}

ETEST_ekill_elevate()
{
    ignore_term()
    {
        disable_die_parent
        die_on_abort
        trap '' SIGTERM
        etestmsg "signals ignored in ${BASHPID}, starting endless loop."
        while true ; do
            :
        done
        ewarn "endless loop finished"
    }

    ignore_term &
    local pid=$!

    assert process_running ${pid}
    local tree=$(process_tree ${pid})
    etestmsg "Background processes running $(lval tree pid)."

    etestmsg "Sending SIGTERM which will be ignored, but ekill will elevate to SIGKILL a second later."
    ekilltree -s=TERM -k=1s ${pid}

    etestmsg "Waiting for processes to get killed."
    eretry -t=2s -T=10s process_not_running ${tree}
}

ETEST_ekill_multiple()
{
    > pids
    yes >/dev/null & echo "$!" >> pids

    local idx
    for (( idx=0; idx<10; ++idx )); do
        sleep infinity &
        echo "$!" >> pids
    done

    local pids=( $(cat pids) )
    etestmsg "Killing all $(lval pids)"
    ekill ${pids[@]}

    etestmsg "Waiting for $(lval pid pids SECONDS)"
    eretry --max-timeout 5s process_not_running ${pids[@]}
}

ETEST_ekilltree()
{
    > pids

    # Create a bunch of background processes
    (
        sleep infinity&        echo "$!" >> pids
        yes >/dev/null&        echo "$!" >> pids
        bash -c 'sleep 1000'&  echo "$!" >> pids

        # Keep the entire subshell from exiting and having above processes get
        # reparented to init.
        sleep infinity || true
    ) &

    local main_pid=$!
    echo "${main_pid}" >> pids

    local pids=( $(cat pids) )
    einfo "Killing $(lval main_pid) -- Expecting death from $(lval pids)"
    ekilltree ${main_pid}

    eretry --timeout 5s process_not_running ${pids[@]}
}

ETEST_ekilltree_excludes_self()
{
    > pid

    try
    {
        sleep infinity&
        echo $! >> pid

        ekilltree -s=TERM ${BASHPID}
        ekilltree -s=KILL ${BASHPID}
    }
    catch
    {
        assert test $? -eq 0
    }

    assert_false process_running $(cat pid)
}

ETEST_ekilltree_exclude_abritrary()
{
    > safe_pid
    > kill_pid

    try
    {
        sleep infinity&
        process_tree $! >> safe_pid

        sleep infinity&
        echo $! >> kill_pid

        ekilltree -x="$(cat safe_pid)" -s=TERM ${BASHPID}
    }
    catch
    {
        assert test $? -eq 0
    }

    etestmsg "Ensuring safe process is still running $(cat safe_pid)"
    assert process_running $(cat safe_pid)
    etestmsg "And that other process is not $(cat kill_pid)"
    ewarn $(ps -ef | grep $(cat kill_pid) || true)
    eretry --timeout 5s process_not_running $(cat kill_pid)
    ewarn $(ps -ef | grep $(cat kill_pid) || true)

    ekill -s=KILL $(cat safe_pid)
}
