#!/usr/bin/env bash

ETEST_emetadata_basic()
{
    cp ${BASH_SOURCE} .
    local src="$(basename ${BASH_SOURCE})"
    local meta="${src}.meta"

    emetadata ${src} > ${meta}
    cat ${meta}
    pack_set MPACK $(cat ${meta})
    $(pack_import MPACK)

    assert_eq "${Filename}" "$(basename "${src}")"
    assert_eq "${Size}"     "$(stat --printf='%s' ${src})"
    assert_eq "${MD5}"      "$(md5sum    ${src} | awk '{print $1}')"
    assert_eq "${SHA256}"   "$(sha256sum ${src} | awk '{print $1}')"
    assert_eq "${SHA512}"   "$(sha512sum ${src} | awk '{print $1}')"

    # Ensure SHA1 has not been exported anymore since it's been broken and is not secure.
    assert_var_empty SHA1
}

# Verify emetadata_check still validates SHA1 field if present even if we don't use it anymore
ETEST_emetadata_sha1_backwards_compatible()
{
    cp ${BASH_SOURCE} .
    local src="$(basename ${BASH_SOURCE})"
    local meta="${src}.meta"
    emetadata ${src} > ${meta}
    
    # Insert legacy SHA1 field by hand since emetadata doesn't do it anymore. This way we can validate
    # that emetadata_check still checks it.
    echo "SHA1=$(sha1sum ${src} | awk '{print $1}')" >> ${meta}
    cat ${meta}
    pack_set MPACK $(cat ${meta})
    $(pack_import MPACK)

    assert_eq "${Filename}" "$(basename "${src}")"
    assert_eq "${Size}"     "$(stat --printf='%s' ${src})"
    assert_eq "${MD5}"      "$(md5sum    ${src} | awk '{print $1}')"
    assert_eq "${SHA1}"     "$(sha1sum   ${src} | awk '{print $1}')"
    assert_eq "${SHA256}"   "$(sha256sum ${src} | awk '{print $1}')"
    assert_eq "${SHA512}"   "$(sha512sum ${src} | awk '{print $1}')"
    
    emetadata_check ${src}
}

ETEST_emetadata_pgp()
{
    [[ ${__BU_OS} == "Darwin" ]] && { ewarn "Test is disabled on Darwin per DT-188." ; return 0 ; }

    local gpgVer=$(gpg --version | grep GnuPG | sed 's/^gpg (GnuPG) //')
    if compare_version "${gpgVer}" ">=" "2.1" ; then
        ewarn "GPG version ${gpgVer} detected, test is disabled for versions 2.1 and later per EMBER-147"
        return 0
    fi

    # Grab public and private keys as well as passphrase
    efetch http://bdr-jenkins.den.solidfire.net:/keys/solidfire_packaging_public.asc  public.asc
    efetch http://bdr-jenkins.den.solidfire.net:/keys/solidfire_packaging_private.asc private.asc
    efetch http://bdr-jenkins.den.solidfire.net:/keys/solidfire_packaging.phrase      phrase.txt

    cp ${BASH_SOURCE} .
    local src="$(basename ${BASH_SOURCE})"
    local meta="${src}.meta"
    emetadata -p="private.asc" -k="$(cat phrase.txt)" ${src} > ${meta}
    cat ${meta}
    pack_set MPACK $(cat ${meta})
    $(pack_import MPACK)

    # Now validate what we just signed using public key
    emetadata_check -p="public.asc" ${src}
}

ETEST_emetadata_failure()
{
    cp ${BASH_SOURCE} .
    local src="$(basename ${BASH_SOURCE})"
    local meta="${src}.meta"

    emetadata ${src} > ${meta}
    cat ${meta}
    pack_set MPACK $(cat ${meta})
    $(pack_import MPACK)

    echo "${SECONDS}" >> ${src}
    assert_false emetadata_check ${src}
}
