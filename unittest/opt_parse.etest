#!/usr/bin/env bash

ETEST_opt_parse()
{
    set -- --file some_file --longer --long --whitespace "arg with whitespace" -shktlc blue -m -n arg1 arg2 arg3
    $(opt_parse                                                             \
        ":file f                     |   Which file should be processed."   \
        ":color c=yellow             |   Color to be used."                 \
        "+long l longer s h k t m n  |   option with lots of variants"      \
        ":whitespace w               |   option expecting to receive something containing whitespace")
    etestmsg "$(opt_dump)"

    assert_eq "blue" "${color}"
    assert_eq "some_file" "${file}"

    assert_eq "arg1" "$1"
    assert_eq "arg2" "$2"
    assert_eq "arg3" "$3"
}

ETEST_opt_parse_boolean()
{
    set -- -a -b -c d e f
    $(opt_parse "+a" "+b" "+c" "+d" "+e" "+f" )
    etestmsg "$(opt_dump)"

    assert_eq 1 "${a}"
    assert_eq 1 "${b}"
    assert_eq 1 "${c}"

    assert_ne 1 "${d:-0}"
    assert_ne 1 "${e:-0}"
    assert_ne 1 "${f:-0}"
}

ETEST_opt_parse_boolean_multi()
{
    set -- --another -va --verbose -vv -s --else
    $(opt_parse          \
        "+verbose v"     \
        "+another a"     \
        "+something s"   \
        "+else e") 
    etestmsg "$(opt_dump)"

    assert_eq 1 "${verbose}"
    assert_eq 1 "${another}"
    assert_eq 1 "${something}"
    assert_eq 1 "${else}"
}

ETEST_opt_parse_short()
{
    set -- -bf a_file -c salmon -d=door
    $(opt_parse                      \
        ":file f    | the file"      \
        "+booealn b | boolean opt"   \
        ":color c   | the color"     \
        ":door d    | another argument")
    etestmsg "$(opt_dump)"


    assert_eq "a_file" "${file}"
    assert_eq "salmon" "${color}"
    assert_eq "door"   "${door}"
}

ETEST_opt_parse_long()
{
    set -- --foo alpha --bar 10 --baz=30
    $(opt_parse \
        ":foo"  \
        ":bar"  \
        ":baz")
    etestmsg "$(opt_dump)"

    assert_eq "alpha" "${foo}"
    assert_eq "10"    "${bar}"
    assert_eq "30"    "${baz}"
}

ETEST_opt_parse_required_arg()
{
    set -- -a
    try
    {
        $(opt_parse ":a") 
        etestmsg "$(opt_dump)"

        die -r=243 "Should have failed parsing options."
    }
    catch
    {
        assert_ne 243 $?
    }
}

ETEST_opt_parse_shorts_crammed_together_with_arg()
{
    set -- -abc optarg arg
    $(opt_parse "+a" "+b" ":c") 
    etestmsg "$(opt_dump)"

    assert_eq 1 "${a}"
    assert_eq 1 "${b}"
    assert_eq optarg "${c}"

    assert_eq "arg" "$1"
}

ETEST_opt_parse_shorts_crammed_together_required_arg()
{
    set -- -abc
    try
    {
        $(opt_parse "+a" "+b" ":c") 
        etestmsg "$(opt_dump)"

        die -r=243 "Should have failed when parsing options but did not."
    }
    catch
    {
        assert_ne 243 $?
    }
}

ETEST_opt_parse_crazy_option_args()
{
    real_alpha="how about	whitespace?"
    real_beta="[]"
    real_gamma="*"
    real_kappa="\$1"

    set -- --alpha "${real_alpha}" --beta "${real_beta}" --gamma "${real_gamma}" --kappa "${real_kappa}"
    $(opt_parse ":alpha" ":beta" ":gamma" ":kappa")
    etestmsg "$(opt_dump)"

    assert_eq "${real_alpha}" "${alpha}"
    assert_eq "${real_gamma}" "${gamma}"
    assert_eq "${real_beta}"  "${beta}"
    assert_eq "${real_kappa}" "${kappa}"
}

ETEST_opt_parse_arg_hyphen()
{
    set -- --foo - arg1
    $(opt_parse ":foo")
    etestmsg "$(opt_dump)"

    [[ "${foo}" == "-" ]] || die "Foo argument was wrong"

    assert_eq "arg1" "$1"
}

ETEST_opt_parse_unexpected_short()
{
    set -- -a
    try
    {
        $(opt_parse "+b")
        etestmsg "$(opt_dump)"

        die -r=243 "Failed to blow up on unexpected option"
    }
    catch
    {
        assert_ne 243 $?
    }
}

ETEST_opt_parse_unexpected_long()
{
    set -- --foo
    try
    {
        $(opt_parse "+bar")
        etestmsg "$(opt_dump)"

        die -r=243 "Failed to blow up on unexpected option"
    }
    catch
    {
        assert_ne 243 $?
    }
}

ETEST_opt_parse_equal_empty()
{
    set -- -f=
    $(opt_parse ":foo f")
    etestmsg "$(opt_dump)"
    assert_empty "${foo}"
}

ETEST_opt_parse_default()
{
    set --
    $(opt_parse                     \
        "+alpha a=1"                \
        ":beta b=3"                 \
        ":white w=with whitespace")
    etestmsg "$(opt_dump)"

    assert_eq 1 "${alpha}"
    assert_eq 3 "${beta}"
    assert_eq "with whitespace" "${white}"
}

ETEST_opt_parse_boolean_defaults()
{
    set -- -a -b
    $(opt_parse "+a=0" "+b=1" "+c=0" "+d=1")
    etestmsg "$(opt_dump)"

    assert_eq 1  "${a}"
    assert_eq 1  "${b}"
    assert_eq 0  "${c}"
    assert_eq 1  "${d}"
}

ETEST_opt_parse_recursive()
{
    foo()
    {
        $(opt_parse    \
            ":as a"    \
            ":be b"    \
            ":c")
        etestmsg "${FUNCNAME}: $(opt_dump)"

        bar --as 6 -b=5 -c 4

        assert_eq 3 "${as}"
        assert_eq 2 "${be}"
        assert_eq 1 "${c}"
    }

    bar()
    {
        $(opt_parse    \
            ":as a"    \
            ":be b"    \
            ":c")
        etestmsg "${FUNCNAME}: $(opt_dump)"

        assert_eq 6 "${as}"
        assert_eq 5 "${be}"
        assert_eq 4 "${c}"

    }

    foo  --as 3 -b=2 -c 1
}

ETEST_opt_parse_dump()
{
    set -- --alpha 10 --beta 20
    $(opt_parse ":alpha" ":beta")

    etestmsg "$(opt_dump)"

    assert_eq 10 "${alpha}"
    assert_eq 20 "${beta}"

    local dump=$(opt_dump)
    [[ "${dump}" =~ alpha ]]
    [[ "${dump}" =~ 10 ]]
    [[ "${dump}" =~ beta ]]
    [[ "${dump}" =~ 20 ]]

}

ETEST_opt_parse_without_options()
{
    etestmsg "Trying to run opt_parse in a function that received no arguments or options"
    set --
    $(opt_parse "+a" ":b" "+c=0")
    etestmsg "$(opt_dump)"
    etestmsg "Succcess."
}

ETEST_opt_parse_no_hyphen_in_name()
{
    try
    {
        set --
        $(opt_parse "+a-b")

        die -r=243 "Should have failed before this."
    }
    catch
    {
        assert_ne 243 $?
    }

}

ETEST_opt_parse_refuses_option_starting_with_no()
{
    try
    {
        $(opt_parse "+no_option")

        die -r=243 "Should have failed before reaching this point."
    }
    catch
    {
        assert_ne 243 $?
    }
}

ETEST_opt_parse_implicit_no()
{
    set -- --no-a --no-b --c --d
    $(opt_parse "+a=1" "+b=0" "+c=1" "+d=0")

    assert_eq "0" "${a}"
    assert_eq "0" "${b}"
    assert_eq "1" "${c}"
    assert_eq "1" "${d}"
}

ETEST_opt_parse_boolean_specify()
{
    set -- -a=0 -b=1 --no-c=0 --no-d=1

    $(opt_parse "+a" "+b" "+c" "+d")

    assert_eq "0" "${a}"
    assert_eq "1" "${b}"
    assert_eq "1" "${c}"
    assert_eq "0" "${d}"
}

ETEST_opt_parse_boolean_validate()
{
    set -- -a=10
    try
    {
        $(opt_parse "+a")
        die -r=243 "Should have already failed."
    }
    catch
    {
        assert_ne 243 $?
    }
}

ETEST_opt_parse_args()
{
    set -- -o option one two more
    $(opt_parse \
        ":option o" \
        "arg1" \
        "arg2")

    assert_eq "option" "${option}"
    assert_eq "one" "${arg1}"
    assert_eq "two" "${arg2}"
    assert_eq 1 $#
    assert_eq more $1
}

ETEST_opt_parse_arg_default()
{
    set -- 
    $(opt_parse "arg1=alpha")
    assert_eq "alpha" "${arg1}"

    set -- b
    $(opt_parse "arg1=alpha")
    assert_eq "b" "${arg1}"
}

ETEST_opt_parse_arg_required()
{
    set --
    try
    {
        $(opt_parse "a")
        die -r=243 "Should have already died."
    }
    catch
    {
        assert_ne 243 $?
    }
}

ETEST_opt_parse_arg_eats_underscores()
{
    set -- one two three more
    $(opt_parse "alpha" "_" "beta")
    declare -p __BU_ARG{,_NAMES,_REQUIRED}
    assert_eq "one" "${alpha}"
    assert_eq "three" "${beta}"
    assert_eq "more" "$*"
    assert_eq 1 $#
}

ETEST_opt_parse_arg_whitespace()
{
    ONE="a b c"
    TWO="  D  E  F  "
    set -- "${ONE}" "${TWO}"
    $(opt_parse "one | docstring" "two | docstring")
    declare -p ONE one TWO two
    assert_eq "${ONE}" "${one}"
    assert_eq "${TWO}" "${two}"
}


ETEST_opt_parse_arg_optional()
{
    set -- "" ""
    $(opt_parse "?a=alpha" "?b")

    assert_eq "" "${a}"
    assert_eq "" "${b}"
}

ETEST_opt_forward()
{
    A_STRING="string with whitespace"
    EXTRA1="EXTRA_1"
    EXTRA2="EXTRA  WITH  WHITESPACE"

    subfunc()
    {
        etestmsg "In subfunc"
        local raw_args=( "$@" )
        einfo "$(ecolor cyan)$(lval raw_args)"
        $(opt_parse \
            ":string"   \
            "+bool"     \
            "+other_bool")
        einfo "$(ecolor cyan)$(declare -p __BU_OPT)"
        assert_eq "${A_STRING}" "${string}"
        assert_eq 1 "${bool}"
        assert_eq 0 "${other_bool}"
    }

    subfunc_extra()
    {
        etestmsg "In subfunc"
        local raw_args=( "$@" )
        einfo "$(ecolor orchid)$(lval raw_args)"
        $(opt_parse \
            ":string"   \
            "+bool"     \
            "+other_bool")
        einfo "$(ecolor orchid)$(declare -p __BU_OPT)"
        assert_eq "${A_STRING}" "${string}"
        assert_eq 1 "${bool}"
        assert_eq 0 "${other_bool}"

        assert_eq "$1" "${EXTRA1}"
        assert_eq "$2" "${EXTRA2}"
    }



    set -- --string "string with whitespace" --bool argument --no-other-bool
    local raw_args=( "$@" )
    einfo "$(ecolor green)$(lval raw_args)"
    $(opt_parse \
        ":string"   \
        "+bool"     \
        "+other_bool")

    einfo "$(ecolor green)$(declare -p __BU_OPT)"
    assert_eq "${A_STRING}" "${string}"
    assert_eq 1 "${bool}"
    assert_eq 0 "${other_bool}"

    etestmsg "calling subfunc"
    opt_forward subfunc string bool other_bool

    etestmsg "Calling subfunc with hyphens"
    opt_forward subfunc string bool other-bool

    etestmsg "calling subfunc with only -- after it"
    opt_forward subfunc string bool --

    etestmsg "calling subfunc_extra"
    opt_forward subfunc_extra string bool -- "${EXTRA1}" "${EXTRA2}"

}
