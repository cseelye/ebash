#!/usr/bin/env bash

#-----------------------------------------------------------------------------
# SETUP / INFRA
#-----------------------------------------------------------------------------

source ${ETEST_TOPDIR}/unittest/daemon_expect.sh

BASHD_PIDFILE=$(readlink -m bashd-$$.pid)
BASHD_QUEUE="/var/run/bashd/$$"
BASHD_PID=

daemon_init BASHD_DAEMON                              \
    "${DAEMON_EXPECT[@]}"                             \
    name="bashd"                                      \
    cmdline="${ETEST_TOPDIR}/bashd -q=${BASHD_QUEUE}" \
    pidfile="${BASHD_PIDFILE}"

bashd_start()
{
    # Start the daemon
    daemon_start BASHD_DAEMON

    # Wait for process to be running
    daemon_expect pre_start
    daemon_expect post_start

    if daemon_not_running BASHD_DAEMON; then
        cat logfile.log
        die "bashd failed to start"
    fi

    assert [[ -s ${BASHD_PIDFILE} ]]
    assert process_running $(cat ${BASHD_PIDFILE})
    assert daemon_running BASHD_DAEMON
    assert daemon_status  BASHD_DAEMON

    # Store the PID for use in various tests
    BASHD_PID=$(cat "${BASHD_PIDFILE}")
}

bashd_stop()
{
    $(declare_args)
    local delete=$(opt_get d 1)

    # Now stop it and verify proper shutdown
    daemon_stop BASHD_DAEMON &
    daemon_expect pre_stop
    daemon_expect post_stop
    wait $!
    assert_false daemon_running BASHD_DAEMON
    assert_false daemon_status -q BASHD_DAEMON
    assert_not_exists ${BASHD_PIDFILE}

    # Optionally delete the queue directory
    if [[ ${delete} -eq 1 ]]; then
        rm --recursive --force --one-file-system "${BASHD_QUEUE}"
    fi
}

bashd_run()
{
    $(declare_args cmdline ?rc ?stdout ?stderr)
    : ${rc:=0}
    local timeout=$(opt_get t "")
    local tmpdir=$(mktemp -d ${BASHD_QUEUE}/bashd-XXXXXX)

    einfo "${tmpdir} :: Starting ${BASHPID} (${cmdline})"
    printf "cmdline=%s\ntimeout=%s\n" "${cmdline}" "${timeout}" > "${tmpdir}/options"

    # Wait for 'rc' to show up indicating the command finished
    while true; do

        if [[ -e "${tmpdir}/rc" ]]; then
            einfo "${tmpdir} :: Complete $BASHPID rc=$(cat ${tmpdir}/rc) stdout=\"$(cat ${tmpdir}/stdout)\" stderr=\"$(cat ${tmpdir}/stderr)\""
            break
        fi

        sleep 0.1
    done

    # Always validate return code and optionally validate STDOUT and STDERR if we were not
    # asked to explicitly ignore them with an expected value of "_".
    assert_eq "${rc}" "$(cat ${tmpdir}/rc)" "${BASHPID} failed (${tmpdir}/rc)"

    if [[ ${stdout} != "_" ]]; then
        assert_eq "${stdout}" "$(cat ${tmpdir}/stdout)" "${BASHPID} failed (${tmpdir}/stdout)"
    fi

    if [[ ${stderr} != "_" ]]; then
        assert_eq "${stderr}" "$(cat ${tmpdir}/stderr)" "${BASHPID} failed (${tmpdir}/stderr)"
    fi
}

#-----------------------------------------------------------------------------
# UNITTESTS
#-----------------------------------------------------------------------------

ETEST_bashd_basic()
{
    bashd_start
    trap_add bashd_stop
}

ETEST_bashd_basic_command()
{
    bashd_start
    trap_add bashd_stop
    bashd_run "whoami" "0" "${USER}" ""
}

ETEST_bashd_parallel()
{
    bashd_start
    trap_add bashd_stop

    local pids=()
    for (( i=0; i<=20; i++ )); do
        bashd_run "sleep ${i}" &
        pids+=( $! )
    done

    # Wait for all backgrounded pids to complete
    local pid
    for pid in ${pids[@]}; do
        wait ${pid}
    done
}

ETEST_bashd_command_spaces()
{
    bashd_start
    trap_add bashd_stop

    assert_not_exists foo
    bashd_run "touch foo"
    assert_exists foo

    assert_not_exists "foo bar"
    bashd_run 'touch "foo bar"'
    assert_exists "foo bar"
}

ETEST_bashd_compound_command()
{
    bashd_start
    trap_add bashd_stop

    assert_not_exists foo bar zap
    bashd_run "touch foo; touch bar; touch zap"
    assert_exists foo bar zap
}

ETEST_bashd_compound_command_with_output()
{
    bashd_start
    trap_add bashd_stop

    bashd_run "echo A; echo B" "0" $'A\nB'
}

ETEST_bashd_pipeline()
{
    bashd_start
    trap_add bashd_stop

    bashd_run "echo foo | grep -o f" "0" "f" ""
}

ETEST_bashd_failure()
{
    bashd_start
    trap_add bashd_stop
    
    bashd_run "false" "1"
}

ETEST_bashd_unknown_command()
{
    bashd_start
    trap_add bashd_stop
 
    bashd_run "foobarzap" "127" "" "bash: foobarzap: command not found"
}

ETEST_bashd_timeout()
{
    bashd_start
    trap_add bashd_stop

    bashd_run -t=1s "sleep infinity" "124" "" "_"
}

# Verify fatal errors inside commands do not cause bashd to fail
ETEST_bashd_signals()
{
    bashd_start
    trap_add bashd_stop
    local pid=$(cat "${BASHD_PIDFILE}")

    local signal
    for signal in ${DIE_SIGNALS[@]}; do

        # Skip TTY_SIGNALS since bashutils interprets these specially and 
        # causes the process to exit with 0.
        if array_contains TTY_SIGNALS "${signal}"; then
            einfo "Skipping TTY $(lval signal TTY_SIGNALS)"
            continue
        fi

        einfo "Testing $(lval signal)"
        
        # bashd must still be running
        assert process_running "${pid}"

        # Send signal to all processes that we're allowed to send it to (e.g. via kill -signal 0)
        # and ensure bashd stays running.
        bashd_run "ulimit -c 0; kill -${signal} 0"           "$(sigexitcode ${signal})" "_" "_"

        # Ensure bashd is still running
        assert process_running "${pid}"
    done
}

ETEST_bashd_stress()
{
    bashd_start
    trap_add bashd_stop

    local iter=0 num_iterations=10 thread=0 num_threads=100
    local uname_output="$(uname -a)"

    for (( iter=0; iter < num_iterations; iter++ )); do
    
        etestmsg "Stress testing: [${iter}/${num_iterations}]"

        local pids=()
        for (( thread=0; thread < num_threads; thread++ )); do
            bashd_run "uname -a" "0" "${uname_output}" &
            pids+=( $! )
        done

        etestmsg "Waiting for background commands: $(lval pids)"
        local pid
        for pid in ${pids[@]}; do
            wait "${pid}"
        done
        unset pids
    done
}

# Verify orphaned commands are killed off when bashd restarts
ETEST_bashd_orphaned()
{
    bashd_start
    trap_add bashd_stop

    # Start a long running task then stop bashd
    bashd_run "sleep infinity" $(sigexitcode SIGKILL) "_" "_" &
    bashd_stop -d=0
 
    # Start bashd and ensure the command is killed
    bashd_start
}

# Verify if a command is queued up while bashd is stopped and it's later started
# that the command is completed as normal.
ETEST_bashd_command_during_crash()
{
    # Start bashd to ensure queue is created. Then stop it to simulate a crash.
    bashd_start
    bashd_stop -d=0

    # Create a command while bashd is not running but background it so we can move on
    # and startup bashd again.
    assert_not_exists stamp
    bashd_run "touch stamp" &
    local pid=$!

    # Start up bashd again as normal
    bashd_start
    trap_add bashd_stop

    # Wait for background process to complete
    wait ${pid}
    assert_eq 0 $?

    # Verify created file
    assert_exists stamp
}

# Verify commands are auto purged after threshold if they are not reaped by the caller
ETEST_bashd_purge()
{
    # Update pack settings for the daemon so it will use a very short purge threshold
    # of 1 second
    pack_set BASHD_DAEMON cmdline="${ETEST_TOPDIR}/bashd -q=${BASHD_QUEUE} -p=1s"
    bashd_start
    trap_add bashd_stop

    # Create a command and ensure it's directory structure stays queued
    bashd_run "touch f1"
    sleep 1s
    assert_exists f1
    assert_eq 2 "$(find ${BASHD_QUEUE} -type d | wc -l)"
    local entry="${BASHD_QUEUE}/$(ls ${BASHD_QUEUE})"
    einfo "Found $(lval entry)"

    # Create some other stuff beneath this directory to ensure it gets purged.
    mkdir ${entry}/junk
    touch ${entry}/junk/{f1,f2,f3,f4}

    # Make sure purging takes care of bind mounts properly.
    mkdir foo ${entry}/foo
    touch foo/{f1,f2,f3,f4}
    ebindmount foo ${entry}/foo

    # Forcibly update the time on all the files to be a day older than reality
    # to ensure they get prunned.
    find "${entry}" -exec touch --date="1 day ago" {} \;

    # Create dummy file inside watched directory just to force it to clean up the command
    touch "${BASHD_QUEUE}/wat"
    eretry -T=5s assert_not_exists "${entry}"
}

ETEST_bashd_multiline_monster_output()
{
    bashd_start
    trap_add bashd_stop

    einfo "Generating input"
    dmesg > input.txt
    einfo "Num lines=$(cat input.txt | wc -l)"

    # Dispatch bashd command to cat massive output and ensure it matches
    bashd_run "cat input.txt" "0" "$(cat input.txt)"
}

ETEST_variable_expansion()
{
    bashd_start
    trap_add bashd_stop

    bashd_run "echo -n \$\$" "0" "_"
    
    # We don't know what the PID will be but make sure it is not the same as bashd's pid and not
    # the same as the subshell bashd created to run the job otherwise it got expanded too early.
    local entry="${BASHD_QUEUE}/$(ls ${BASHD_QUEUE})"
    local pid=$(cat ${entry}/pid)
    local stdout=$(cat ${entry}/stdout)
    einfo "Found $(lval entry pid stdout)"
    
    assert_ne "${BASHD_PID}" "${stdout}"
    assert_ne "${pid}"       "${stdout}"
}
