#!/usr/bin/env bash

[[ ${__BU_OS} == Linux ]] || return 0

check_mounts()
{
    $(opt_parse path count)

    [[ ${count} -eq 0 ]] && assert_false emounted ${path} || assert_true emounted ${path}
    assert_eq ${count} $(emount_count ${path})
}

ETEST_emount_bind()
{
    mkdir src
    touch src/file
    echo "Love" > src/file

    # Bind mount and verify mounted and verify content
    mkdir dst
    ebindmount src dst
    trap_add "eunmount dst"
    assert_true emounted dst
    assert_true diff src/file dst/file
}

ETEST_emount_unmount()
{
    # Bind mount src to dst
    mkdir src dst
    ebindmount src dst
    trap_add "eunmount dst"

    # Verify mounted, unmount, then verify unmounted
    assert_true  emounted dst
    assert_false emounted src
}

ETEST_emount_unmount_recursive()
{
    etestmsg "Bind mounting src1 and src2"
    mkdir -p src1 src2 dst/dst1 dst/dst2
    ebindmount src1 dst/dst1
    ebindmount src2 dst/dst2
    trap_add "eunmount dst/dst1 dst/dst2"

    etestmsg "Validating mounts"
    assert_false emounted dst
    assert_true  emounted dst/dst1
    assert_true  emounted dst/dst2

    etestmsg "Ensure eunmount does nothing without -r flag"
    local mounts_before=( $(efindmnt "${TEST_DIR_OUTPUT}") )
    einfo "Mounts before unmount"
    echo "${mounts_before[@]}"
    eunmount dst
    einfo "Mounts after unmount"
    local mounts_after=( $(efindmnt "${TEST_DIR_OUTPUT}") )
    echo "${mounts_after[@]}"
    assert_eq "$(array_join mounts_before :)" "$(array_join mounts_after :)"

    etestmsg "Recursively unmounting dst"
    einfo "Mounts before unmount"
    list_mounts | grep "${TEST_DIR_OUTPUT}" || true
    eunmount -r dst
    einfo "Mounts after unmount"
    list_mounts | grep "${TEST_DIR_OUTPUT}" || true
    
    etestmsg "Validating mounts"
    assert_false emounted dst/dst1
    assert_false emounted dst/dst2
}

ETEST_emount_partial_match()
{
    # Bind mount a couple of nested directories
    mkdir -p src1 src2 dst/dst1 dst/dst2
    ebindmount src1 dst/dst1
    ebindmount src2 dst/dst2
    trap_add "eunmount dst/dst1 dst/dst2"

    # Verify state
    assert_false emounted dst
    assert_true  emounted dst/dst1
    assert_true  emounted dst/dst2

    # Use a partial match -- should NOT find any mounts
    assert_false emounted dst/d
}

# Verify "eunmount -v" enables verbose output.
ETEST_eunmount_verbose()
{
    mkdir src dest
    ebindmount src dest
    trap_add "eunmount dest"

    local output=$(EFUNCS_COLOR=0 eunmount -v dest 2>&1)
    assert_match "${output}" "Unmounting dest"
}

# Verify eunmount -d behavior
ETEST_eunmount_delete()
{
    etestmsg "Creating non-empty directory"
    mkdir -p dest
    touch dest/{1,2,3}

    etestmsg "Verifying eunmount -d fails without -r flag"
    assert_false eunmount -d dest
    assert_exists dest

    etestmsg "Retest with -r flag"
    assert_true eunmount -r -d dest
    assert_not_exists dest
}

# Verify eunmount -a behavior
ETEST_eunmount_all()
{
    mkdir src dest

    etestmsg "Mounting src at dest many times"
    local nmounts=10
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        mkdir dest/${i}
        ebindmount src dest/${i}
        trap_add "eunmount dest/${i}"
    done

    # eunmount -a dest without -r should SUCCEED but do NOTHING
    # since dest itself is not mounted.
    etestmsg "Verifying eunmount -a without -r does nothing"
    assert_true eunmount -a dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_true emounted dest/${i}
    done

    # With -r it should succeed but nothing should get removed (no -d)
    etestmsg "Verifying eunmount -a -r succeeds"
    assert_true eunmount -a -r dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_false emounted dest/${i}
        assert_exists dest/${i}
    done

    etestmsg "Verifying eunmount -a -d behavior"
    assert_true eunmount -a -r -d dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_false emounted dest/${i}
        assert_not_exists dest/${i}
    done

    etestmsg "Mounting everything again"
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        mkdir -p dest/${i}
        ebindmount src dest/${i}
    done

    etestmsg "Verifying eunmount -a -r -d behavior"
    assert_true eunmount -a -r -d dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_false emounted dest/${i}
        assert_not_exists dest/${i}
    done

    assert_not_exists dest
}


