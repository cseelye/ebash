#!/usr/bin/env bash

[[ ${__BU_OS} == Linux ]] || return 0

check_mounts()
{
    $(declare_args path count)

    [[ ${count} -eq 0 ]] && assert_false emounted ${path} || assert_true emounted ${path}
    assert_eq ${count} $(emount_count ${path})
}

ETEST_emount_bind()
{
    mkdir src
    touch src/file
    echo "Love" > src/file

    # Bind mount and verify mounted and verify content
    mkdir dst
    ebindmount src dst
    trap_add "eunmount dst"
    assert_true emounted dst
    assert_true diff src/file dst/file
}

ETEST_emount_unmount()
{
    # Bind mount src to dst
    mkdir src dst
    ebindmount src dst
    trap_add "eunmount dst"

    # Verify mounted, unmount, then verify unmounted
    assert_true  emounted dst
    assert_false emounted src
}

ETEST_emount_unmount_recursive()
{
    etestmsg "Bind mounting src1 and src2"
    mkdir -p src1 src2 dst/dst1 dst/dst2
    ebindmount src1 dst/dst1
    ebindmount src2 dst/dst2
    trap_add "eunmount dst/dst1 dst/dst2"

    etestmsg "Validating mounts"
    assert_false emounted dst
    assert_true  emounted dst/dst1
    assert_true  emounted dst/dst2

    etestmsg "Ensure eunmount does nothing without -r flag"
    local mounts_before=( $(efindmnt "${TEST_DIR_OUTPUT}") )
    einfo "Mounts before unmount"
    echo "${mounts_before[@]}"
    eunmount dst
    einfo "Mounts after unmount"
    local mounts_after=( $(efindmnt "${TEST_DIR_OUTPUT}") )
    echo "${mounts_after[@]}"
    assert_eq "$(array_join mounts_before :)" "$(array_join mounts_after :)"

    etestmsg "Recursively unmounting dst"
    einfo "Mounts before unmount"
    grep "${TEST_DIR_OUTPUT}" /proc/mounts || true
    eunmount -r dst
    einfo "Mounts after unmount"
    grep "${TEST_DIR_OUTPUT}" /proc/mounts || true
    
    etestmsg "Validating mounts"
    assert_false emounted dst/dst1
    assert_false emounted dst/dst2
}

ETEST_emount_partial_match()
{
    # Bind mount a couple of nested directories
    mkdir -p src1 src2 dst/dst1 dst/dst2
    ebindmount src1 dst/dst1
    ebindmount src2 dst/dst2
    trap_add "eunmount dst/dst1 dst/dst2"

    # Verify state
    assert_false emounted dst
    assert_true  emounted dst/dst1
    assert_true  emounted dst/dst2

    # Use a partial match -- should NOT find any mounts
    assert_false emounted dst/d
}

ETEST_emount_bind_count_separate()
{
    mkdir src

    # Mount a few times and ensure counter goes up correctly
    local nmounts=10
    for (( i=0; i<${nmounts}; ++i )); do
        mkdir dst${i}
        emount --bind src dst${i}
        check_mounts dst${i} 1
    done

    # Umount and verify counts go down properly
    for (( i=${nmounts}-1; i>=0; --i )); do
        eunmount dst${i}
        check_mounts dst${i} 0
    done
}

ETEST_emount_bind_count_shared()
{
    mkdir src dst

    etestmsg "Mounting several times to ensure mount count goes up correctly"
    local nmounts=10
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        emount --bind src dst
        emount --make-private dst
        check_mounts dst $((i+1))
    done

    etestmsg "Umounting to verify counts go down properly"
    for (( i=${nmounts}; i>0; --i )); do
        einfo "$(lval i)"
        eunmount dst
        check_mounts dst $((i-1))
    done
}

# Test bugfix where if you bind mount a directory (or file) and later 
# remove the source of the bind mount then we were unable to unmount
# the destination mount point and it would get caught in an infinite
# loop.
ETEST_emount_bind_orphaned()
{
    einfo "Creating src and dst"
    mkdir src dst
    einfo "Bind mounting src to dst"
    emount --bind src dst
    emounted dst || die
    assert_eq 1 $(emount_count dst)

    # Remove the source of the bind mount and verify we still
    # recongize it's mounted (as we had a bug in emounted as well).
    # NOTE: NO --one-file-system here as we purposefully want to cause
    #       this problem. That also means we have to byass our 'rm' function.
    einfo "Remove src and verify still mounted"
    command rm --recursive --force src
    emounted dst || die
    assert_eq 1 $(emount_count dst)

    # Ensure eunmount can unmount it and doesn't hang.
    einfo "Unmount dst and verify not mounted"
    eunmount dst
    emounted dst && die
    assert_eq 0 $(emount_count dst)
}

# Verify "emount -v" and "emount --verbose" enable verbose output.
ETEST_emount_verbose()
{
    mkdir src dest
    local output=$(EFUNCS_COLOR=0 emount --bind --verbose src dest 2>&1)
    trap_add "eunmount dest"

    assert_match "${output}" "- Mounting --bind --verbose src dest"
}

# Verify "eunmount -v" enables verbose output.
ETEST_eunmount_verbose()
{
    mkdir src dest
    ebindmount src dest
    trap_add "eunmount dest"

    local output=$(EFUNCS_COLOR=0 eunmount -v dest 2>&1)
    assert_match "${output}" ">> Unmounting dest"
}

# Verify eunmount -d behavior
ETEST_eunmount_delete()
{
    etestmsg "Creating non-empty directory"
    mkdir -p dest
    touch dest/{1,2,3}

    etestmsg "Verifying eunmount -d fails without -r flag"
    assert_false eunmount -d dest
    assert_exists dest

    etestmsg "Retest with -r flag"
    assert_true eunmount -r -d dest
    assert_not_exists dest
}

# Verify eunmount -a behavior
ETEST_eunmount_all()
{
    mkdir src dest

    etestmsg "Mounting src at dest many times"
    local nmounts=10
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        mkdir dest/${i}
        ebindmount src dest/${i}
        trap_add "eunmount dest/${i}"
    done

    # eunmount -a dest without -r should SUCCEED but do NOTHING
    # since dest itself is not mounted.
    etestmsg "Verifying eunmount -a without -r does nothing"
    assert_true eunmount -a dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_true emounted dest/${i}
    done

    # With -r it should succeed but nothing should get removed (no -d)
    etestmsg "Verifying eunmount -a -r succeeds"
    assert_true eunmount -a -r dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_false emounted dest/${i}
        assert_exists dest/${i}
    done

    etestmsg "Verifying eunmount -a -d behavior"
    assert_true eunmount -a -r -d dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_false emounted dest/${i}
        assert_not_exists dest/${i}
    done

    etestmsg "Mounting everything again"
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        mkdir -p dest/${i}
        ebindmount src dest/${i}
    done

    etestmsg "Verifying eunmount -a -r -d behavior"
    assert_true eunmount -a -r -d dest
    for (( i=0; i<${nmounts}; ++i )); do
        einfo "$(lval i)"
        assert_false emounted dest/${i}
        assert_not_exists dest/${i}
    done

    assert_not_exists dest
}


