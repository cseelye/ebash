#!/usr/bin/env bash

# Helper function to call either eprompt, epromptyn or eprompt_with_options and assert that it has the expected return
# code and output based on the provided input.
assert_eprompt()
{
    $(opt_parse \
        ":rc=0    | Expected return code." \
        "+yn      | Call epromptyn instead of eprompt." \
        ":options | Options that are valid (call eprompt_with_options intead of eprompt)." \
        ":secret  | Secret options (call eprompt_with_options instead of eprompt.)" \
        "?input   | Input to send to eprompt." \
        "?stdout  | Expected stdout.")

    if [[ ${yn} -eq 1 ]]; then
        $(tryrc --rc=actual_rc --stdout=actual_stdout "echo \"${input}\" | epromptyn \"Input\"")
    elif [[ -n "${options}" || -n "${secret}" ]]; then
        $(tryrc --rc=actual_rc --stdout=actual_stdout "echo \"${input}\" | eprompt_with_options \"Input\" \"${options}\" \"${secret}\"")
    else
        $(tryrc --rc=actual_rc --stdout=actual_stdout "echo \"${input}\" | eprompt \"Input\"")
    fi

    assert_eq "${rc}"     "${actual_rc}"
    assert_eq "${stdout}" "${actual_stdout}"
}

ETEST_eprompt_basic()
{
    assert_eprompt "${USER}" "${USER}"
}

ETEST_eprompt_spaces()
{
    local input="This is an input string with spaces"
    assert_eprompt "${input}" "${input}"
}

# eprompt only reads a single line of input and it is not currently allowed to contain newlines. This test is designed
# to test that behavior.
ETEST_eprompt_single_line()
{
    local input=$'First\nSecond'
    assert_eprompt "${input}" "First"
}

ETEST_epromptyn_case()
{
    assert_eprompt --yn "Yes" "Yes"
    assert_eprompt --yn "YES" "Yes"
    assert_eprompt --yn "YeS" "Yes"
    assert_eprompt --yn "yes" "Yes"
    assert_eprompt --yn "No"  "No"
    assert_eprompt --yn "NO"  "No"
    assert_eprompt --yn "no"  "No"
}

ETEST_epromptyn_invalid()
{
    assert_eprompt --yn --rc 143 "Foobar"
}

ETEST_eprompt_options()
{
    assert_eprompt --options "Option1,Option2,Option3" "Option1" "Option1"
    assert_eprompt --options "Option1,Option2,Option3" "Option2" "Option2"
    assert_eprompt --options "Option1,Option2,Option3" "Option3" "Option3"
}

ETEST_eprompt_options_invalid()
{
    assert_eprompt --options "Option1,Option2,Option3" --rc 143 "Invalid"
}

ETEST_eprompt_options_secret()
{
    assert_eprompt --options "Option1,Option2,Option3" --secret "Secret1,Secret2" "Option1" "Option1"
    assert_eprompt --options "Option1,Option2,Option3" --secret "Secret1,Secret2" "Secret2" "Secret2"
}

# Verify internal behavior of eprompt_dialog_read with regards to how it handles whitespace and multi-byte keys
ETEST_eprompt_dialog_read()
{
    local char=""

    # Basic sanity test of reading a single character
    $(printf "A" | eprompt_dialog_read char)
    assert_eq "A" "${char}"

    # Ensure it can deal with whitespace properly
    $(printf " " | eprompt_dialog_read char)
    assert_eq " " "${char}"

    # If we feed it multiple characters that are not multi-byte arrow keys it should only read the first one
    $(printf "ABCD" | eprompt_dialog_read char)
    assert_eq "A" "${char}"

    # Verify it handles all our mult-byte special keys properly
    etestmsg "Verifying multi-byte special keys"
    local key val
    for key in UP DOWN RIGHT LEFT TAB ESC ENTER BACKSPACE DELETE; do
        eval "val=\${KEY_${key}}"
        einfos "Verifying $(lval key val)"
        $(printf "${val}" | eprompt_dialog_read char)
        assert_eq "${val}" "${char}"
    done
}

# Key sequence when we're done with eprompt_dialog and want to hit "OK"
KEY_DONE="${KEY_TAB}${KEY_LEFT}${KEY_ENTER}"

# Setup flags we want to use for all these tests
EPROMPT_DIALOG="eprompt_dialog --hide --trace"

ETEST_eprompt_dialog_single()
{
    local input="Locke${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} philo1)
    assert_eq "Locke" "${philo1}"
}

# Test multiple input fields. Also verifies that the down arrow key is used to seamlessly navigate between fields
# without having to press ENTER to exit the first field and enter the second field.
ETEST_eprompt_dialog_multi()
{
    local input="Locke${KEY_DOWN}Hobbes${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} philo1 philo2)
    assert_eq "Locke"  "${philo1}"
    assert_eq "Hobbes" "${philo2}"
}

ETEST_eprompt_dialog_multi_spaces()
{
    local input="Locke${KEY_DOWN}Thomas Hobbes${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} philo1 philo2)
    assert_eq "Locke"         "${philo1}"
    assert_eq "Thomas Hobbes" "${philo2}"
}

ETEST_eprompt_dialog_optional()
{
    local input="${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} ?field1)
    assert_empty "${field1}"
}

ETEST_eprompt_dialog_optional_multi_first()
{
    # There are three input fields, but we skip the second one. Because it's marked optional this should pass.
    local input="${KEY_DOWN}Locke${KEY_DOWN}Hobbes${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} ?philo1 philo2 philo3)
    assert_empty       "${philo1}"
    assert_eq "Locke"  "${philo2}"
    assert_eq "Hobbes" "${philo3}"
}

ETEST_eprompt_dialog_optional_multi_middle()
{
    # There are three input fields, but we skip the second one. Because it's marked optional this should pass.
    local input="Locke${KEY_DOWN}${KEY_DOWN}Hobbes${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} philo1 ?philo2 philo3)
    assert_eq "Locke"  "${philo1}"
    assert_empty       "${philo2}"
    assert_eq "Hobbes" "${philo3}"
}

ETEST_eprompt_dialog_optional_multi_last()
{
    # There are three input fields, but we skip the second one. Because it's marked optional this should pass.
    local input="Locke${KEY_DOWN}Hobbes${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} philo1 philo2 ?philo3)
    assert_eq "Locke"  "${philo1}"
    assert_eq "Hobbes" "${philo2}"
    assert_empty       "${philo3}"
}

ETEST_eprompt_dialog_move_without_edit()
{
    local input="${KEY_DOWN}${KEY_DOWN}${KEY_DOWN}${KEY_UP}${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} ?philo1 ?philo2 ?philo3)
    assert_empty "${philo1}"
    assert_empty "${philo2}"
    assert_empty "${philo3}"
}

ETEST_eprompt_dialog_default_values()
{
    local input="${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} "?philo1=John Locke" "?philo2=Kant" "?philo3=John Stuart Mill")
    assert_eq "John Locke"       "${philo1}"
    assert_eq "Kant"             "${philo2}"
    assert_eq "John Stuart Mill" "${philo3}"
}

ETEST_eprompt_dialog_default_values_override()
{
    # Since we intend to overwrite the existing values we need to delete the keys already present.
    local input="${KEY_DELETE}Thomas Jefferson${KEY_DOWN}${KEY_DOWN}${KEY_DELETE}John Rawls${KEY_DONE}"
    $(printf "${input}" | ${EPROMPT_DIALOG} "?philo1=A" "?philo2=Kant" "?philo3=_")
    assert_eq "Thomas Jefferson" "${philo1}"
    assert_eq "Kant"             "${philo2}"
    assert_eq "John Rawls"       "${philo3}"
}

# Wherever we are in the dialog menu, escape key should take us out immediately.
ETEST_eprompt_dialog_escape()
{
    try
    {
        $(disable_die_parent; printf "${KEY_ESC}" | ${EPROMPT_DIALOG} ?philo1 ?philo2 ?philo3)
        die "Should have failed due to ESCAPE key being pressed"
    }
    catch
    {
        assert_eq ${DIALOG_CANCEL} $?
    }
}

ETEST_eprompt_dialog_escape_during_input()
{
    etestmsg "Sending KEY_DELETE | Thomas Jefferson | KEY_DOWN | KEY_DOWN | KEY_DELETE | John $(print_value KEY_ESC)"
    local input="${KEY_DELETE}Thomas Jefferson${KEY_DOWN}${KEY_DELETE}${KEY_DELETE}John ${KEY_ESC}"
 
    try
    {
        $(disable_die_parent; printf "${input}" | ${EPROMPT_DIALOG} ?philo1 ?philo2 ?philo3)
        die "Should have failed due to ESCAPE key being pressed"
    }
    catch
    {
        assert_eq ${DIALOG_CANCEL} $?
    }
}
