#!/usr/bin/env bash

OUTPUT=ticks-$$

# Fake EPROGRESS function body to use in some of the tests which
# don't want the real do_eprogress
FAKE_DO_EPROGRESS='
{
    trap "exit 0" ${DIE_SIGNALS[@]}

    local tick=0
    rm --force ${OUTPUT}

    while true; do
        echo "${tick}" >> ${OUTPUT}
        (( tick++ )) || true
        sleep 0.10   || true
    done
}
'

wait_for_eprogress()
{
    while true; do
        [[ -s ${OUTPUT} ]] && return 0
        sleep .1
    done
}

wait_for_ticks()
{
    $(opt_parse expected)

    while true; do
        local actual=$(tail -1 ${OUTPUT} || true)
        [[ ${actual} -ge ${expected} ]] && return 0
        
        echo "Ticks: ${actual}/${expected}"
        sleep .1
    done
}

ETEST_eprogress_ticks()
{
    override_function do_eprogress "${FAKE_DO_EPROGRESS}"

    eprogress "Waiting 1 second"
    wait_for_ticks 9
    eprogress_kill
}

ETEST_eprogress_ticks_reuse()
{
    override_function do_eprogress "${FAKE_DO_EPROGRESS}"

    eprogress "Waiting for Ubuntu to stop sucking"
    wait_for_ticks 5
    eprogress_kill
    
    eprogress "Waiting for Gentoo to replace Ubuntu"
    wait_for_ticks 5
    eprogress_kill
}

# Verify EPROGRESS_TICKER can be used to forcibly enable/disable ticker
ETEST_eprogress_ticker_off()
{
    (
        exec &> >(tee ${OUTPUT})

        COLUMNS=28
        EFUNCS_COLOR=0
        EDEBUG=0
        ETRACE=0
        EINTERACTIVE=0
        EMSG_PREFIX=""
        eprogress "Waiting"
        eprogress_kill

    )

    wait_for_eprogress
    assert_eq ">> Waiting.[ ok ]" "$(cat ${OUTPUT})"
}

ETEST_eprogress_ticker_on()
{
    type eprogress
    etestmsg "Starting background process that writes to ${OUTPUT}"
    (
        exec &> >(tee ${OUTPUT})

        COLUMNS=28
        EFUNCS_COLOR=0
        EDEBUG=0
        ETRACE=0
        EINTERACTIVE=1
        EMSG_PREFIX=""
        # Output stored in this test expects what it would look like if term
        # were screen-256color
        TERM=screen-256color
        eprogress "Waiting"
        eprogress_kill
    )

    etestmsg "Waiting for eprogress to run."
    wait_for_eprogress

    etestmsg "${OUTPUT} contents"
    cat ${OUTPUT}
    etestmsg "End ${OUTPUT} contents"

    # The ticker may actuall run for slightly longer than we requested due to
    # how sleep works. Change instances of 00:00:0[1-9] to 00:00:00 in the output
    # for easier validation.
    sed -i "s|:01\]|:00\]|g" ${OUTPUT}

    # Different terms have different codes.  Ignore the number in the ANSI code.
    sed -i "s|\[[0-9]\+C||" ${OUTPUT}

    assert_eq ">> Waiting [00:00:00]  ^H/^H-^H\^H|^H/^H-^H\^H|^H \$"$'\n'"^[M^[[ ok ]\$" "$(cat -evt ${OUTPUT})"
}

ETEST_eprogress_inside_eretry()
{
    override_function do_eprogress "${FAKE_DO_EPROGRESS}"

    etestmsg "Starting eprogress"
    eprogress "Waiting for eretry"
    $(tryrc eretry false)
    eprogress_kill
    assert test "$(tail -1 ${OUTPUT} || true)" -ge 5
}

ETEST_eprogress_kill_before_eprogress()
{
    eprogress_kill
}

ETEST_eprogress_killall()
{
    eprogress "Processing" &> /dev/null
    eprogress "More Stuff" &> /dev/null

    local pids=( "${__BU_EPROGRESS_PIDS[@]}" )
    assert_eq 2 $(array_size pids)
   
    local pid=
    for pid in "${pids[@]}"; do
        assert process_running ${pid}
    done

    # Kill all eprogress pids and verify they exit
    eprogress_kill -a
    for pid in "${pids[@]}"; do
        eretry -t=2s -T=10s process_not_running ${pid}
    done
}

ETEST_eprogress_killall_empty()
{
    eprogress_kill -a
}

