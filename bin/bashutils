#!/usr/bin/env bash

: ${BASHUTILS_HOME:=$(dirname $0)/..}
: ${BASHUTILS:=${BASHUTILS_HOME}/share}
source ${BASHUTILS}/bashutils.sh || { echo "Unable to source ${BASHUTILS}/bashutils.sh" ; exit 1 ; }

#
# This tool is designed to run individual commands in a bashutils environment.
# It can effectively turns bashutils functions into commands that can easily be
# run from a shell prompt.
#
# The first simple use case happens when the binary is called "bashutils".  In
# this mode, everything after bashutils on the command line is evaluated inside
# a bash interpreter that has sourced the various bashutils source files.
#
# But bashutils can be symlinked to other names.  Bashutils pays attention to
# the name that it is called by.  When it's not called as bashutils, it tries
# to run bashutils functions intead.  First, it looks to see if the symlink
# name is the name of a "namespace" of bashutils commands.  For instance, the
# string commands can be used in this way.  Assuming a "string" symlink, then
#    
#     string trim " a string to trim "
#
# will call the string_trim function, passing it that string as an argument.
# If there is no function that's a combination of the symlink name and the
# first argument, then bashutils will look for a function of the same name as
# the symlink and call it passing all arguments to the function.  For instance,
# given a symlink called eunmount, then you could call
#
#     eunmount /path/to/unmount /another/path
#
# And both "/path/to/unmount" and "/another/path" will be passed as arguments
# to eunmount.
#

$(opt_parse \
    ":source s | Bashutils should source the specified file before attempting to run the specified command.")

CALLED_NAME="${0##*/}"

args=( "${@}" )

if [[ -n ${source} ]] ; then
    source "${source}"
fi

# If not called as bashutils...
if [[ "${CALLED_NAME}" != "bashutils" ]] ; then

    # If there's a function in the group with the specified command name call
    # it
    if declare -f "${CALLED_NAME}_${1}" &>/dev/null ; then

        # Run the command, but pretend to be inside a try so that die doesn't
        # print an ugly stack trace.
        __BU_INSIDE_TRY=1
        quote_eval "${CALLED_NAME}_${1}" "${args[@]:1}"

    # Otherwise assume the called name is also the name of a bashutils function
    # and pass everything as arguments to it.
    else
        # Run the command, but pretend to be inside a try so that die doesn't
        # print an ugly stack trace.
        __BU_INSIDE_TRY=1
        quote_eval "${CALLED_NAME}" "${args[@]}"
    fi

# However, if called as bashutils...
else

    # Use all arguments to bashutils as a command to execute
    if [[ ${#args[@]} -gt 0 ]] ; then
        # Run the command, but pretend to be inside a try so that die doesn't
        # print an ugly stack trace.
        __BU_INSIDE_TRY=1
        quote_eval "${args[@]}"

    # Or run ibu if nothing was specified
    else
        exec ${BASHUTILS_HOME}/bin/ibu --source "${source}"
    fi

fi


