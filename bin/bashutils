#!/usr/bin/env bash

#
# This tool is designed to run individual commands in a bashutils environment.
# It can effectively turns bashutils functions into commands that can easily be
# run from a shell prompt.
#
# The first simple use case happens when the binary is called "bashutils".  In
# this mode, everything after bashutils on the command line is evaluated inside
# a bash interpreter that has sourced the various bashutils source files.
#
# But bashutils can be symlinked to other names.  Bashutils pays attention to
# the name that it is called by.  When it's not called as bashutils, it tries
# to run bashutils functions intead.  First, it looks to see if the symlink
# name is the name of a "namespace" of bashutils commands.  For instance, the
# string commands can be used in this way.  Assuming a "string" symlink, then
#    
#     string trim " a string to trim "
#
# will call the string_trim function, passing it that string as an argument.
# If there is no function that's a combination of the symlink name and the
# first argument, then bashutils will look for a function of the same name as
# the symlink and call it passing all arguments to the function.  For instance,
# given a symlink called eunmount, then you could call
#
#     eunmount /path/to/unmount /another/path
#
# And both "/path/to/unmount" and "/another/path" will be passed as arguments
# to eunmount.
#
#-------------------------------------------------------------------------------


# To be able to make good use of function documentation in places where we do
# something like this, we need to save function documentation off into
# variables (or else we'd have to parse bash source code enough to extract it,
# which sounds very error prone)
#
#     somefunc --help
#
# But we don't want to bloat the interpreter with a bunch of documentation
# every time we source bashutils.  Our solution is to only save them at times
# where we believe the variables are going to be needed.  There's no reason to
# expect they will be necessary unless `--help` is on the command line
# somewhere.  Or for those few cases where it's needed, they can set this
# variable, too.
#
# And for this to work in all of the bashutils files, we must do it before
# sourcing them.
for arg in "$@" ; do
    if [[ ${arg} == "--help" ]] ; then
        __BU_SAVE_DOC=1
    fi
done


: ${BASHUTILS_HOME:=$(dirname $0)/..}
: ${BASHUTILS:=${BASHUTILS_HOME}/share}
source ${BASHUTILS}/bashutils.sh || { echo "Unable to source ${BASHUTILS}/bashutils.sh" ; exit 1 ; }

$(opt_parse \
    ":source s        | Bashutils should source the specified file before attempting to run the specified command." \
    ":name n=${0##*/} | Name to use as a starting point for finding functions.  I.e pretend bashutils is running with the specified name.")

args=( "${@}" )

if [[ -n ${source} ]] ; then
    source "${source}"
fi

# If not called as bashutils...
if [[ "${name}" != "bashutils" ]] ; then

    # If there's a function in the group with the specified command name call
    # it
    if declare -f "${name}_${1}" &>/dev/null ; then

        # Run the command, but pretend to be inside a try so that die doesn't
        # print an ugly stack trace.
        quote_eval "${name}_${1}" "${args[@]:1}"

    # Otherwise assume the called name is also the name of a bashutils function
    # and pass everything as arguments to it.
    else
        # Run the command, but pretend to be inside a try so that die doesn't
        # print an ugly stack trace.
        quote_eval "${name}" "${args[@]}"
    fi

# However, if called as bashutils...
else

    # Use all arguments to bashutils as a command to execute
    if [[ ${#args[@]} -gt 0 ]] ; then
        # Run the command, but pretend to be inside a try so that die doesn't
        # print an ugly stack trace.
        quote_eval "${args[@]}"

    # Or run ibu if nothing was specified
    else
        exec ${BASHUTILS_HOME}/bin/ibu --source "${source}"
    fi

fi
