#!/usr/bin/env bash

#
# This tool is designed to run individual commands in a bashutils environment.
# It can effectively turns bashutils functions into commands that can easily be
# run from a shell prompt.
#
# The first simple use case happens when the binary is called "bashutils".  In
# this mode, everything after bashutils on the command line is evaluated inside
# a bash interpreter that has sourced the various bashutils source files.
#
# But bashutils can be symlinked to other names.  Bashutils pays attention to
# the name that it is called by.  When it's not called as bashutils, it tries
# to run bashutils functions intead.  First, it looks to see if the symlink
# name is the name of a "namespace" of bashutils commands.  For instance, the
# string commands can be used in this way.  Assuming a "string" symlink, then
#    
#     string trim " a string to trim "
#
# will call the string_trim function, passing it that string as an argument.
# If there is no function that's a combination of the symlink name and the
# first argument, then bashutils will look for a function of the same name as
# the symlink and call it passing all arguments to the function.  For instance,
# given a symlink called eunmount, then you could call
#
#     eunmount /path/to/unmount /another/path
#
# And both "/path/to/unmount" and "/another/path" will be passed as arguments
# to eunmount.
#
#-------------------------------------------------------------------------------


# To be able to make good use of function documentation in places where we do
# something like this, we need to save function documentation off into
# variables (or else we'd have to parse bash source code enough to extract it,
# which sounds very error prone)
#
#     somefunc --help
#
# But we don't want to bloat the interpreter with a bunch of documentation
# every time we source bashutils.  Our solution is to only save them at times
# where we believe the variables are going to be needed.  There's no reason to
# expect they will be necessary unless `--help` is on the command line
# somewhere.  Or for those few cases where it's needed, they can set this
# variable, too.
#
# And for this to work in all of the bashutils files, we must do it before
# sourcing them.
for arg in "$@" ; do
    if [[ ${arg} == "--help" ]] ; then
        __BU_SAVE_DOC=1
    fi
done


: ${BASHUTILS_HOME:=$(readlink -m "$(dirname $0)/..")}
: ${BASHUTILS:=${BASHUTILS_HOME}/share}
source ${BASHUTILS}/bashutils.sh || { echo "Unable to source ${BASHUTILS}/bashutils.sh" ; exit 1 ; }


declare name=${0##*/}

# If we were called as "bashutils", then the caller can specify options to this script.
if [[ ${name} == "bashutils" ]] ; then

    $(opt_parse \
        ":load l          | Bashutils should source the specified file before attempting to run the specified command." \
        "+source s        | Print commands that would load bashutils from its existing location on disk into the current
                            shell and then exit.  You'd use this in a script like this: \$(bashutils --load)" \
        "+print_environment printenv p | Dump environment variables that bashutils would like to use in a format bash
                            can interpret" \
        ":name n=${0##*/} | Name to use as a starting point for finding functions.  I.e pretend bashutils is running
                            with the specified name.")

    if [[ -n ${load} ]] ; then
        source "${load}"
    fi

    if [[ ${source} -eq 1 ]] ; then
        echo "eval export BASHUTILS=${BASHUTILS} ; source \"${BASHUTILS}/bashutils.sh\" || { echo \"Unable to source ${BASHUTILS}/bashtuils.sh\" ; exit 1 ; }"
        exit 0
    elif [[ ${print_environment} -eq 1 ]] ; then
        printf "export BASHUTILS=%q\n" "${BASHUTILS}"
        printf "export BASHUTILS_HOME=%q\n" "${BASHUTILS_HOME}"
        exit 0
    fi
fi

# If not called as bashutils...
if [[ "${name}" != "bashutils" ]] ; then

    # If there's a function in the group with the specified command name call
    # it
    if [[ -n ${1:-} ]] && declare -f "${name}_${1}" &>/dev/null ; then

        quote_eval "${name}_${1}" "${@:2}"

    # Otherwise assume the called name is also the name of a bashutils function
    # and pass everything as arguments to it.
    else
        quote_eval "${name}" "${@:1}"
    fi

# However, if called as bashutils...
else

    # Use all arguments to bashutils as a command to execute
    if [[ ${#@} -gt 0 ]] ; then
        # Run the command, but pretend to be inside a try so that die doesn't
        # print an ugly stack trace.
        quote_eval "${@}"

    # Or run ibu if nothing was specified
    else
        exec ${BASHUTILS_HOME}/bin/ibu --load "${load}"
    fi

fi
